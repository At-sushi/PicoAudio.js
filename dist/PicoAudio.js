/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./PicoAudio.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./PicoAudio.js":
/*!**********************!*\
  !*** ./PicoAudio.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar PicoAudio = function () {\n  function PicoAudio(_audioContext, _picoAudio) {\n    this.debug = false;\n    this.isStarted = false;\n    this.isPlayed = false;\n    this.isTonyu2 = false;\n    this.settings = {\n      masterVolume: 1,\n      generateVolume: 0.15,\n      tempo: 120,\n      basePitch: 440,\n      resolution: 480,\n      isWebMIDI: false,\n      WebMIDIPortOutputs: null,\n      WebMIDIPortOutput: null,\n      WebMIDIPort: -1,\n      // -1:auto\n      WebMIDIPortSysEx: true,\n      // MIDIデバイスのフルコントロールをするかどうか（SysExを使うかどうか）(httpsじゃないと使えない？)\n      isReverb: true,\n      // リバーブONにするか\n      reverbVolume: 1.5,\n      isChorus: true,\n      chorusVolume: 0.5,\n      isCC111: true,\n      loop: false,\n      isSkipBeginning: this.isTonyu2,\n      // 冒頭の余白をスキップ(Tonyu2はtrue)\n      isSkipEnding: true,\n      // 末尾の空白をスキップ\n      holdOnValue: 64,\n      maxPoly: -1,\n      // 同時発音数 -1:infinity\n      maxPercPoly: -1,\n      // 同時発音数(パーカッション) -1:infinity\n      isOfflineRendering: false,\n      // TODO 演奏データを作成してから演奏する\n      isSameDrumSoundOverlap: false // 同じドラムの音が重なることを許容するか\n\n    };\n    this.events = [];\n    this.trigger = {\n      isNoteTrigger: true,\n      play: function play() {},\n      stop: function stop() {},\n      noteOn: function noteOn() {},\n      noteOff: function noteOff() {},\n      songEnd: function songEnd() {}\n    };\n    this.states = {\n      isPlaying: false,\n      startTime: 0,\n      stopTime: 0,\n      stopFuncs: [],\n      webMIDIWaitState: null,\n      webMIDIStopTime: 0,\n      playIndices: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      updateBufTime: 50,\n      updateBufMaxTime: 50,\n      updateIntervalTime: 0,\n      latencyLimitTime: 0\n    };\n    this.hashedDataList = [];\n    this.hashedMessageList = [];\n    this.playData = null;\n    this.channels = [];\n    this.tempoTrack = [{\n      timing: 0,\n      value: 120\n    }, {\n      timing: 0,\n      value: 120\n    }];\n    this.cc111Time = -1;\n    this.onSongEndListener = null;\n\n    for (var i = 0; i < 17; i++) {\n      this.channels.push([0, 0, 1]);\n    } // AudioContextがある場合はそのまま初期化、なければAudioContextを用いる初期化をinit()で\n\n\n    if (_audioContext) {\n      this.init(_audioContext, _picoAudio);\n    } // Fallback\n    // Unsupport performance.now()\n\n\n    if (typeof performance === \"undefined\") {\n      window.performance = {};\n    }\n\n    if (!performance.now) {\n      performance.now = function now() {\n        return Date.now();\n      };\n    } // Unsupport Number.MAX_SAFE_INTEGER\n\n\n    if (!Number.MAX_SAFE_INTEGER) {\n      Number.MAX_SAFE_INTEGER = 9007199254740991;\n    }\n  }\n\n  PicoAudio.prototype.init = function (_audioContext, _picoAudio) {\n    if (this.isStarted) return;\n    this.isStarted = true;\n    var AudioContext = window.AudioContext || window.webkitAudioContext;\n    this.context = _audioContext ? _audioContext : new AudioContext();\n\n    if (_picoAudio && _picoAudio.whitenoise) {\n      // 使いまわし\n      this.whitenoise = _picoAudio.whitenoise;\n    } else {\n      this.whitenoise = this.context.createBuffer(2, this.context.sampleRate, this.context.sampleRate); // 乱数パターンを固定にする（Math.random()を使わない）\n      // Xorshiftアルゴリズム\n\n      var x = 123456789;\n      var y = 362436069;\n      var z = 521288629;\n      var w = 8867512;\n\n      for (var ch = 0; ch < 2; ch++) {\n        for (var i = 0; i < this.context.sampleRate; i++) {\n          var t = x ^ x << 11;\n          x = y;\n          y = z;\n          z = w;\n          var r = w = this.w ^ this.w >>> 19 ^ (t ^ t >>> 8);\n          r = Math.abs(r) / 2147483648 % 2;\n          this.whitenoise.getChannelData(ch)[i] = r * 2 - 1;\n        }\n      }\n    } // リアルタイムで音量変更するためにdestination前にgainNodeを一つ噛ませる\n\n\n    this.masterGainNode = this.context.createGain();\n    this.masterGainNode.gain.value = this.settings.masterVolume; // リバーブ用のインパルス応答音声データ作成（てきとう）\n\n    if (_picoAudio && _picoAudio.impulseResponse) {\n      // 使いまわし\n      this.impulseResponse = _picoAudio.impulseResponse;\n    } else {\n      var sampleLength = this.context.sampleRate * 3.5;\n      this.impulseResponse = this.context.createBuffer(2, sampleLength, this.context.sampleRate);\n\n      for (var ch = 0; ch < 2; ch++) {\n        var buf = this.impulseResponse.getChannelData(ch);\n\n        for (var i = 0; i < sampleLength; i++) {\n          var v = (sampleLength - i) / sampleLength;\n          var s = i / this.context.sampleRate;\n          var r = i / sampleLength;\n          var d = (s < 0.030 ? 0 : v) * (s >= 0.030 && s < 0.031 ? v * 2 : v) * (s >= 0.040 && s < 0.042 ? v * 1.5 : v) * (s >= 0.050 && s < 0.054 ? v * 1.25 : v) * Math.random() * 0.2 * Math.pow(v - 0.030, 4);\n          buf[i] = d;\n        }\n      }\n    } // リバーブ用\n\n\n    this.convolver = this.context.createConvolver();\n    this.convolver.buffer = this.impulseResponse;\n    this.convolver.normalize = true;\n    this.convolverGainNode = this.context.createGain();\n    this.convolverGainNode.gain.value = this.settings.reverbVolume;\n    this.convolver.connect(this.convolverGainNode);\n    this.convolverGainNode.connect(this.masterGainNode);\n    this.masterGainNode.connect(this.context.destination); // コーラス用\n\n    this.chorusDelayNode = this.context.createDelay();\n    this.chorusGainNode = this.context.createGain();\n    this.chorusOscillator = this.context.createOscillator();\n    this.chorusLfoGainNode = this.context.createGain();\n    this.chorusDelayNode.delayTime.value = 0.025;\n    this.chorusLfoGainNode.gain.value = 0.010;\n    this.chorusOscillator.frequency.value = 0.05;\n    this.chorusGainNode.gain.value = this.settings.chorusVolume;\n    this.chorusOscillator.connect(this.chorusLfoGainNode);\n    this.chorusLfoGainNode.connect(this.chorusDelayNode.delayTime);\n    this.chorusDelayNode.connect(this.chorusGainNode);\n    this.chorusGainNode.connect(this.masterGainNode);\n    this.masterGainNode.connect(this.context.destination);\n    this.chorusOscillator.start(0); // リバーブON設定を引き継ぐ。未設定ならパフォーマンス計測する(Tonyu2用)\n\n    if (this.isTonyu2) {\n      if (_picoAudio) {\n        this.settings.isReverb = _picoAudio.settings.isReverb;\n      } else {\n        this.settings.isReverb = this.measurePerformanceReverb();\n      }\n    }\n  };\n\n  PicoAudio.prototype.addEventListener = function (type, func) {\n    // type = EventName (play, stop, noteOn...)\n    this.events.push({\n      type: type,\n      func: func\n    });\n  };\n\n  PicoAudio.prototype.fireEvent = function (type, option) {\n    this.events.forEach(function (event) {\n      if (event.type == type) {\n        try {\n          event.func(option);\n        } catch (e) {\n          console.log(e);\n        }\n      }\n    });\n  };\n\n  PicoAudio.prototype.createNote = function (option) {\n    var note = this.createBaseNote(option, false, true, false, true); // oscillatorのstopはこちらで実行するよう指定\n\n    if (note.isGainValueZero) return null;\n    var oscillator = note.oscillator;\n    var gainNode = note.gainNode;\n    var stopGainNode = note.stopGainNode;\n    var isPizzicato = false;\n    var isNoiseCut = false;\n    var that = this; // 音色別の音色振り分け 書き方(ry\n\n    switch (this.channels[note.channel][0] / 10 || option.instrument) {\n      // Sine\n      case 0.1:\n      case 6:\n      case 15:\n      case 24:\n      case 26:\n      case 46:\n      case 50:\n      case 51:\n      case 52:\n      case 53:\n      case 54:\n      case 82:\n      case 85:\n      case 86:\n        {\n          oscillator.type = \"sine\";\n          gainNode.gain.value *= 1.5;\n          break;\n        }\n      // Square\n\n      case 0.2:\n      case 4:\n      case 12:\n      case 13:\n      case 16:\n      case 19:\n      case 20:\n      case 32:\n      case 34:\n      case 45:\n      case 48:\n      case 49:\n      case 55:\n      case 56:\n      case 57:\n      case 61:\n      case 62:\n      case 63:\n      case 71:\n      case 72:\n      case 73:\n      case 74:\n      case 75:\n      case 76:\n      case 77:\n      case 78:\n      case 79:\n      case 80:\n      case 84:\n        {\n          oscillator.type = \"square\";\n          gainNode.gain.value *= 0.8;\n          break;\n        }\n      // Sawtooth\n\n      case 0.3:\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n      case 7:\n      case 17:\n      case 18:\n      case 21:\n      case 22:\n      case 23:\n      case 27:\n      case 28:\n      case 29:\n      case 30:\n      case 36:\n      case 37:\n      case 38:\n      case 39:\n      case 40:\n      case 41:\n      case 42:\n      case 43:\n      case 44:\n      case 47:\n      case 59:\n      case 64:\n      case 65:\n      case 66:\n      case 67:\n      case 68:\n      case 69:\n      case 70:\n      case 71:\n      case 82:\n      case 87:\n        {\n          oscillator.type = \"sawtooth\";\n          break;\n        }\n      // Triangle\n\n      case 0.4:\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 14:\n      case 25:\n      case 31:\n      case 33:\n      case 35:\n      case 58:\n      case 60:\n      case 83:\n      case 88:\n      case 89:\n      case 90:\n      case 91:\n      case 92:\n      case 93:\n      case 94:\n      case 95:\n        {\n          oscillator.type = \"triangle\";\n          gainNode.gain.value *= 1.5;\n          break;\n        }\n      // Other - Square\n\n      default:\n        {\n          oscillator.type = \"square\";\n        }\n    } // 音の終わりのプチプチノイズが気になるので、音の終わりに5ms減衰してノイズ軽減\n\n\n    if ((oscillator.type == \"sine\" || oscillator.type == \"triangle\") && !isPizzicato && note.stop - note.start > 0.01) {\n      isNoiseCut = true;\n    } // 音色別の減衰　書き方ミスったなあ\n\n\n    switch (this.channels[note.channel][1] / 10 || option.instrument) {\n      // ピッチカート系減衰\n      case 0.2:\n      case 12:\n      case 13:\n      case 45:\n      case 55:\n        {\n          isPizzicato = true;\n          gainNode.gain.value *= 1.1;\n          gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);\n          gainNode.gain.linearRampToValueAtTime(0.0, note.start + 0.2);\n          that.stopAudioNode(oscillator, note.start + 0.2, stopGainNode);\n          break;\n        }\n      // ピアノ程度に伸ばす系\n\n      case 0.3:\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 6:\n      case 9:\n      case 11:\n      case 14:\n      case 15:\n      case 32:\n      case 36:\n      case 37:\n      case 46:\n      case 47:\n        {\n          gainNode.gain.value *= 1.1;\n          gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);\n          var decay = (128 - option.pitch) / 64;\n          gainNode.gain.setTargetAtTime(0, note.start, 2.5 * decay * decay);\n          that.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);\n          break;\n        }\n      // ギター系\n\n      case 0.4:\n      case 24:\n      case 25:\n      case 26:\n      case 27:\n      case 28:\n      case 29:\n      case 30:\n      case 31:\n      case 34:\n        {\n          gainNode.gain.value *= 1.1;\n          gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);\n          gainNode.gain.linearRampToValueAtTime(0.0, note.start + 1.0 + note.velocity * 4);\n          that.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);\n          break;\n        }\n      // 減衰していくけど終わらない系\n\n      case 0.5:\n      case 4:\n      case 5:\n      case 7:\n      case 8:\n      case 10:\n      case 33:\n      case 35:\n        {\n          gainNode.gain.value *= 1.0;\n          gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);\n          gainNode.gain.linearRampToValueAtTime(gainNode.gain.value * 0.95, note.start + 0.1);\n          gainNode.gain.setValueAtTime(gainNode.gain.value * 0.95, note.start + 0.1);\n          gainNode.gain.linearRampToValueAtTime(0.0, note.start + 2.0 + note.velocity * 10);\n          that.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);\n          break;\n        }\n\n      case 119:\n        // Reverse Cymbal\n        {\n          gainNode.gain.value = 0;\n          that.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);\n          var note2 = this.createBaseNote(option, true, true);\n          if (note2.isGainValueZero) break;\n          note2.oscillator.playbackRate.setValueAtTime((option.pitch + 1) / 128, note.start);\n          note2.gainNode.gain.setValueAtTime(0, note.start);\n          note2.gainNode.gain.linearRampToValueAtTime(1.3, note.start + 2);\n          that.stopAudioNode(note2.oscillator, note.stop, note2.stopGainNode);\n          break;\n        }\n\n      default:\n        {\n          gainNode.gain.value *= 1.1;\n          gainNode.gain.setValueAtTime(gainNode.gain.value, note.start);\n          that.stopAudioNode(oscillator, note.stop, stopGainNode, isNoiseCut);\n        }\n    }\n\n    return function () {\n      that.stopAudioNode(oscillator, 0, stopGainNode, true);\n      if (note2 && note2.oscillator) that.stopAudioNode(note2.oscillator, 0, note2.stopGainNode, true);\n    };\n  };\n\n  PicoAudio.prototype.createPercussionNote = function (option) {\n    var note = this.createBaseNote(option, true, false);\n    if (note.isGainValueZero) return null;\n    var source = note.oscillator;\n    var gainNode = note.gainNode;\n    var stopGainNode = note.stopGainNode;\n    var start = note.start;\n    var velocity = 1; // ドラム全体の音量調整用\n\n    var note2 = this.createBaseNote(option, false, false, true);\n    var oscillator = note2.oscillator;\n    var gainNode2 = note2.gainNode;\n    var stopGainNode2 = note2.stopGainNode;\n    var nextSameNoteOnInterval = option.nextSameNoteOnInterval;\n    var that = this; // oscillator.frequency.setValueAtTime()がcurrentTimeより遅れると周波数設定がされないので対策\n\n    if (start < this.context.currentTime) start = this.context.currentTime;\n    var stopAudioTime = 0;\n    var stopAudioTime2 = 0;\n\n    switch (option.pitch) {\n      // Bass Drum\n      case 35: // Acoustic Bass Drum\n\n      case 36:\n        // Bass Drum\n        // w\n        source.playbackRate.value = 0.25;\n        gainNode.gain.setValueAtTime(0, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * 0.7, start + 0.004);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.008);\n        stopAudioTime = 0.008; // s\n\n        oscillator.frequency.setValueAtTime(option.pitch == 35 ? 90 : 160, start);\n        oscillator.frequency.linearRampToValueAtTime(40, start + 0.08);\n        gainNode2.gain.setValueAtTime(0, start);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.02);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.08);\n        stopAudioTime2 = 0.08;\n        break;\n      // Snare Drum\n\n      case 37:\n        // Side Stick\n        // w\n        source.playbackRate.value = 0.26;\n        gainNode.gain.setValueAtTime(velocity * 1.5, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.041);\n        stopAudioTime = 0.041; // s\n\n        oscillator.frequency.setValueAtTime(330, start);\n        oscillator.frequency.linearRampToValueAtTime(120, start + 0.02);\n        gainNode2.gain.setValueAtTime(velocity, start);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.02);\n        stopAudioTime2 = 0.02;\n        break;\n\n      case 38: // Acoustic Snare\n\n      case 40:\n        // Electric Snare\n        var len = option.pitch == 38 ? 0.25 : 0.2; // w\n\n        source.playbackRate.value = 0.7;\n        gainNode.gain.setValueAtTime(velocity, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + len);\n        stopAudioTime = len; // s\n\n        oscillator.frequency.setValueAtTime(option.pitch == 38 ? 140 : 200, start);\n        oscillator.frequency.linearRampToValueAtTime(option.pitch == 38 ? 100 : 160, start + 0.1);\n        gainNode2.gain.setValueAtTime(velocity * 2, start);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.1);\n        stopAudioTime2 = 0.1;\n        break;\n\n      case 39:\n        // Hand Clap\n        // w\n        source.playbackRate.value = 0.5;\n        gainNode.gain.setValueAtTime(velocity * 1.3, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.010);\n        gainNode.gain.setValueAtTime(velocity * 1.3, start + 0.0101);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.020);\n        gainNode.gain.setValueAtTime(velocity * 1.3, start + 0.0201);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.09);\n        stopAudioTime = 0.09; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(180, start);\n        gainNode2.gain.setValueAtTime(velocity * 0.8, start);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.010);\n        gainNode2.gain.setValueAtTime(velocity * 0.8, start + 0.0101);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.020);\n        gainNode2.gain.setValueAtTime(velocity * 0.8, start + 0.0201);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.030);\n        stopAudioTime2 = 0.11;\n        break;\n      // Toms\n\n      case 41: // Low Floor Tom\n\n      case 43: // High Floor Tom\n\n      case 45: // Low Tom\n\n      case 47: // Low-Mid Tom\n\n      case 48: // High-Mid Tom\n\n      case 50:\n        // High Tom\n        var len = option.pitch - 41 + (option.pitch >= 48 ? 1 : 0); // w\n\n        source.playbackRate.value = 0.3 + len / 45;\n        gainNode.gain.setValueAtTime(velocity * 1.5, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.02);\n        stopAudioTime = 0.02; // s\n\n        oscillator.frequency.setValueAtTime(90 + 15 * len, start);\n        oscillator.frequency.linearRampToValueAtTime(30 + 7.5 * len, start + 0.5 - len / 35);\n        gainNode2.gain.setValueAtTime(velocity * 1.5, start);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.5 - len / 35);\n        stopAudioTime2 = 0.5 - len / 35;\n        break;\n      // Hi-hat\n\n      case 42: // Closed High-Hat\n\n      case 44:\n        // Pedal High-Hat\n        // w\n        source.playbackRate.value = 1;\n\n        if (option.pitch == 42) {\n          gainNode.gain.setValueAtTime(velocity * 0.8, start);\n        } else {\n          gainNode.gain.setValueAtTime(0, start);\n          gainNode.gain.linearRampToValueAtTime(velocity * 0.8, start + 0.014);\n        }\n\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);\n        stopAudioTime = 0.08; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n\n      case 46:\n        // Open Hihat\n        // w\n        source.playbackRate.setValueAtTime(0.35, start);\n        source.playbackRate.linearRampToValueAtTime(0.6, start + 0.1);\n        source.playbackRate.linearRampToValueAtTime(1, start + 0.3);\n        gainNode.gain.setValueAtTime(velocity * 1.1, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.3);\n        stopAudioTime = 1.5; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n      // Cymbal\n\n      case 49: // Crash Cymbal 1\n\n      case 57:\n        // Crash Cymbal 2\n        // w\n        var r = option.pitch == 49 ? 0.3 : 0.5;\n        var r2 = option.pitch == 49 ? 0.4 : 0.7;\n        source.playbackRate.setValueAtTime(r, start);\n        source.playbackRate.linearRampToValueAtTime(r2, start + 0.15);\n        source.playbackRate.linearRampToValueAtTime(0.9, start + 0.4);\n        gainNode.gain.setValueAtTime(velocity * 1.3, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.35);\n        stopAudioTime = 2; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n\n      case 51: // Ride Cymbal 1\n\n      case 59:\n        // Ride Cymbal 2\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 0.9, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.35);\n        stopAudioTime = 2; // s\n\n        oscillator.type = \"triangle\";\n        var f = option.pitch == 51 ? 372 : 400;\n        oscillator.frequency.setValueAtTime(f, start);\n        gainNode2.gain.setValueAtTime(velocity * 0.4, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.35);\n        stopAudioTime2 = 2;\n        break;\n\n      case 52:\n        // Chinese Cymbal\n        // w\n        source.playbackRate.setValueAtTime(0.17, start);\n        source.playbackRate.linearRampToValueAtTime(0.25, start + 0.1);\n        source.playbackRate.linearRampToValueAtTime(0.5, start + 0.6);\n        gainNode.gain.setValueAtTime(velocity * 1.3, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.35);\n        stopAudioTime = 2; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(382, start);\n        gainNode2.gain.setValueAtTime(velocity * 0.2, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.35);\n        stopAudioTime2 = 2;\n        break;\n\n      case 53:\n        // Ride Bell\n        // w\n        source.playbackRate.setValueAtTime(0.6, start);\n        gainNode.gain.setValueAtTime(velocity, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.3);\n        stopAudioTime = 2; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(377, start);\n        gainNode2.gain.setValueAtTime(velocity * 0.5, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.35);\n        stopAudioTime2 = 2;\n        break;\n\n      case 55:\n        // Splash Cymbal\n        // w\n        source.playbackRate.setValueAtTime(0.5, start);\n        source.playbackRate.linearRampToValueAtTime(0.8, start + 0.1);\n        source.playbackRate.linearRampToValueAtTime(1, start + 0.6);\n        gainNode.gain.setValueAtTime(velocity * 1.5, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.3);\n        stopAudioTime = 1.75; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n      // Bell\n\n      case 54: // Tambourine\n\n      case 56:\n        // Cowbell\n        // w\n        source.playbackRate.setValueAtTime(1, start);\n        var v = option.pitch == 54 ? 1 : 0.4;\n        var len = option.pitch == 54 ? 0.01 : 0;\n        gainNode.gain.setValueAtTime(velocity * v / 2, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * v, start + len);\n        gainNode.gain.setTargetAtTime(0, start + len, 0.05);\n        stopAudioTime = 0.3; // s\n\n        oscillator.frequency.setValueAtTime(option.pitch == 54 ? 6000 : 495, start);\n        var v = option.pitch == 54 ? 1 : 2;\n        gainNode2.gain.setValueAtTime(velocity * v / 2, start);\n        gainNode2.gain.linearRampToValueAtTime(velocity * v, start + len);\n        gainNode2.gain.setTargetAtTime(0, start + len, 0.05);\n        stopAudioTime2 = 0.3;\n        break;\n\n      case 58:\n        // Vibraslap\n        // w s\n        source.playbackRate.setValueAtTime(0.6, start);\n        source.playbackRate.linearRampToValueAtTime(1, start + 0.8);\n        var len = 40;\n        gainNode.gain.setValueAtTime(velocity * 1.5, start);\n        gainNode2.gain.setValueAtTime(velocity * 0.5, start);\n\n        for (var i = 0; i < len; i++) {\n          gainNode.gain.linearRampToValueAtTime(velocity * 0.1 * (len - i) / len, start + i / len * 0.8);\n          gainNode.gain.linearRampToValueAtTime(velocity * 1.5 * (len - (i + 1)) / len, start + (i + 0.99) / len * 0.8);\n          gainNode2.gain.linearRampToValueAtTime(velocity * 0.025 * (len - i) / len, start + i / len * 0.8);\n          gainNode2.gain.linearRampToValueAtTime(velocity * 0.25 * (len - (i + 1)) / len, start + (i + 0.99) / len * 0.8);\n        }\n\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.8);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.8);\n        stopAudioTime = 0.8; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(1000, start);\n        stopAudioTime2 = 0.8;\n        break;\n\n      case 80:\n        // Mute Triangle\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 0.5, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.015);\n        stopAudioTime = 0.2; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(6000, start);\n        gainNode2.gain.setValueAtTime(velocity * 2.5, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.02);\n        stopAudioTime2 = 0.3;\n        break;\n\n      case 81:\n        // Open Triangle\n        // w\n        source.playbackRate.value = 5;\n        gainNode.gain.setValueAtTime(velocity * 0.5, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.08);\n        stopAudioTime = 0.75; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(6000, start);\n        gainNode2.gain.setValueAtTime(velocity * 2.5, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.18);\n        stopAudioTime2 = 1;\n        break;\n      // Other Percussion\n\n      case 60: // High Bongo\n\n      case 61: // Low Bongo\n\n      case 62: // Mute High Conga\n\n      case 63: // Open High Conga\n\n      case 64:\n        // Low Conga\n        var p = option.pitch;\n        var r = p == 60 ? 700 : p == 61 ? 282 : p == 62 ? 385 : p == 63 ? 295 : 210;\n        var len = p == 60 ? 0.08 : p == 61 ? 0.1 : p == 62 ? 0.03 : p == 63 ? 0.12 : 0.15; // w\n\n        source.playbackRate.value = 0.03;\n        gainNode.gain.setValueAtTime(velocity * 1.2, start);\n        stopAudioTime = 0.03; // s\n\n        oscillator.frequency.setValueAtTime(r * 0.97, start);\n        oscillator.frequency.linearRampToValueAtTime(r, start + len);\n        gainNode2.gain.setValueAtTime(velocity * 1.8, start);\n        gainNode2.gain.linearRampToValueAtTime(0, start + len);\n        stopAudioTime2 = len;\n        break;\n\n      case 65: // High Timbale\n\n      case 66:\n        // Low Timbale\n        var len = option.pitch == 65 ? 0.22 : 0.25; // w\n\n        source.playbackRate.setValueAtTime(option.pitch == 65 ? 0.25 : 0.22, start);\n        source.playbackRate.linearRampToValueAtTime(option.pitch == 65 ? 0.2 : 0.18, start + len);\n        gainNode.gain.setValueAtTime(velocity * 1.3, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * 0.2, start + len / 3.5);\n        gainNode.gain.linearRampToValueAtTime(0, start + len);\n        stopAudioTime = len; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(option.pitch == 65 ? 190 * 1.07 : 136 * 1.07, start);\n        oscillator.frequency.linearRampToValueAtTime(option.pitch == 65 ? 190 : 136, start + 0.1);\n        gainNode2.gain.setValueAtTime(velocity * 3.2, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.08);\n        stopAudioTime2 = 1;\n        break;\n\n      case 67: // High Agogo\n\n      case 68:\n        // Low Agogo\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 0.5, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * 0.1, start + 0.02);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);\n        stopAudioTime = 0.08; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(option.pitch == 67 ? 1430 : 1055, start);\n        gainNode2.gain.setValueAtTime(velocity * 2, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.06);\n        stopAudioTime2 = 0.75;\n        break;\n\n      case 69:\n        // Cabasa\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 0.3, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * 0.8, start + 0.03);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.08);\n        stopAudioTime = 0.08; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n\n      case 70:\n        // Maracas\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 1.2, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.06);\n        stopAudioTime = 0.06; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n\n      case 71: // Short Whistle\n\n      case 72:\n        // Long Whistle\n        // w\n        gainNode.gain.value = 0;\n        stopAudioTime = 0; // s\n\n        var len = option.pitch == 71 ? 0.07 : 0.4;\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(option.pitch == 71 ? 2408 : 2105, start);\n        gainNode2.gain.setValueAtTime(0, start);\n\n        for (var i = 0; i < len * 74; i++) {\n          gainNode2.gain.linearRampToValueAtTime(velocity * 2.5, start + (i + 0.2) / 75);\n          gainNode2.gain.linearRampToValueAtTime(velocity * 0.5, start + (i + 0.9) / 75);\n        }\n\n        gainNode2.gain.linearRampToValueAtTime(0, start + len);\n        stopAudioTime2 = len;\n        break;\n\n      case 73: // Short Guiro\n\n      case 74:\n        // Long Guiro\n        // w\n        var len = option.pitch == 73 ? 0.05 : 0.35;\n        source.playbackRate.setValueAtTime(option.pitch == 73 ? 0.2 : 0.2, start);\n        source.playbackRate.linearRampToValueAtTime(option.pitch == 73 ? 0.7 : 0.5, start + len);\n        gainNode.gain.value = velocity * 0.2;\n\n        for (var i = 0; i < len * 100; i++) {\n          gainNode.gain.setValueAtTime(velocity * 0.4, start + i / 100);\n          gainNode.gain.setValueAtTime(velocity * 0.9, start + (i + 0.7) / 100);\n        }\n\n        stopAudioTime = len; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n\n      case 75:\n        // Claves\n        // w\n        gainNode.gain.value = 0;\n        stopAudioTime = 0; // s\n\n        oscillator.frequency.setValueAtTime(2181, start);\n        gainNode2.gain.setValueAtTime(0, start);\n        gainNode2.gain.setValueAtTime(velocity * 2, start + 0.005);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 1, start + 0.015);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 1.5, start + 0.025);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.08);\n        stopAudioTime2 = 0.1;\n        break;\n\n      case 76: // High Wood Block\n\n      case 77:\n        // Low Wood Block\n        // w\n        source.playbackRate.value = 0.1;\n        gainNode.gain.setValueAtTime(velocity * 1.2, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.015);\n        stopAudioTime = 0.015; // s\n\n        oscillator.frequency.setValueAtTime(option.pitch == 76 ? 800 : 600, start);\n        gainNode2.gain.setValueAtTime(0, start);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.005);\n        gainNode2.gain.setTargetAtTime(0, start + 0.005, 0.02);\n        stopAudioTime2 = 0.2;\n        break;\n\n      case 78: // Close Cuica\n\n      case 79:\n        // Open Cuica\n        // w\n        gainNode.gain.value = 0;\n        stopAudioTime = 0; // s\n\n        var len = 0.18;\n        var f = option.pitch == 78 ? 750 : 270;\n        oscillator.frequency.setValueAtTime(f, start);\n        oscillator.frequency.linearRampToValueAtTime(f, start + len / 3);\n        if (option.pitch == 78) oscillator.frequency.linearRampToValueAtTime(f * 0.9, start + len);\n        gainNode2.gain.setValueAtTime(0, start);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 1.5, start + 0.005);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 0.5, start + 0.02);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 3, start + 0.04);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 2, start + len / 4 * 3);\n        gainNode2.gain.linearRampToValueAtTime(0, start + len);\n        stopAudioTime2 = len;\n        break;\n      // GS, GM2\n\n      case 27:\n        // High Q\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 1, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.002);\n        stopAudioTime = 0.002; // s\n\n        oscillator.frequency.setValueAtTime(1500, start);\n        oscillator.frequency.linearRampToValueAtTime(280, start + 0.015);\n        oscillator.frequency.linearRampToValueAtTime(0, start + 0.07);\n        gainNode2.gain.setValueAtTime(velocity * 1.9, start);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.07);\n        stopAudioTime2 = 0.07;\n        break;\n\n      case 28:\n        // Slap\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 1.3, start);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.010);\n        gainNode.gain.setValueAtTime(velocity * 1.1, start + 0.0101);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.020);\n        gainNode.gain.setValueAtTime(velocity * 0.9, start + 0.0201);\n        gainNode.gain.setTargetAtTime(0, start + 0.0201, 0.03);\n        stopAudioTime = 0.2; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n\n      case 29: // Scratch Push\n\n      case 30:\n        // Scratch Pull\n        var t1 = option.pitch == 29 ? 0.05 : 0.07;\n        var t2 = option.pitch == 29 ? 0.06 : 0.09;\n        var t3 = option.pitch == 29 ? 0.07 : 0.11;\n        var t4 = option.pitch == 29 ? 0.1 : 0.15;\n        var t5 = option.pitch == 29 ? 0.25 : 0.4; // w\n\n        var r1 = option.pitch == 29 ? 0.1 : 0.06;\n        var r2 = option.pitch == 29 ? 0.3 : 0.2;\n        var r3 = option.pitch == 29 ? 0.18 : 0.12;\n        source.playbackRate.setValueAtTime(r1, start);\n        source.playbackRate.linearRampToValueAtTime(r2, start + t1);\n        source.playbackRate.linearRampToValueAtTime(0, start + t2);\n        source.playbackRate.linearRampToValueAtTime(r2, start + t3);\n        source.playbackRate.linearRampToValueAtTime(r3, start + t4);\n        source.playbackRate.linearRampToValueAtTime(0, start + t5);\n        gainNode.gain.setValueAtTime(0, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * 0.4, start + t1);\n        gainNode.gain.linearRampToValueAtTime(velocity * 0.1, start + t3);\n        gainNode.gain.linearRampToValueAtTime(velocity * 0.3, start + t4);\n        gainNode.gain.linearRampToValueAtTime(0, start + t5);\n        stopAudioTime = t5; // s\n\n        var r4 = option.pitch == 29 ? 500 : 400;\n        var r5 = option.pitch == 29 ? 1950 : 1200;\n        var r6 = option.pitch == 29 ? 430 : 250;\n        oscillator.frequency.setValueAtTime(r4, start);\n        oscillator.frequency.linearRampToValueAtTime(r5, start + t1);\n        oscillator.frequency.linearRampToValueAtTime(0, start + t2);\n        oscillator.frequency.linearRampToValueAtTime(r5, start + t3);\n        oscillator.frequency.linearRampToValueAtTime(r6, start + t4);\n        oscillator.frequency.linearRampToValueAtTime(0, start + t5);\n        gainNode2.gain.setValueAtTime(0, start);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 0.7, start + t1);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 0.2, start + t3);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 0.6, start + t4);\n        gainNode2.gain.linearRampToValueAtTime(0, start + t5);\n        stopAudioTime2 = t5;\n        break;\n\n      case 31:\n        // Sticks\n        // w\n        source.playbackRate.setValueAtTime(0.4, start);\n        source.playbackRate.linearRampToValueAtTime(0.5, start + 0.015);\n        gainNode.gain.setValueAtTime(velocity * 1.2, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.035);\n        stopAudioTime = 0.3; // s\n\n        oscillator.frequency.setValueAtTime(3140, start);\n        gainNode2.gain.setValueAtTime(velocity * 1.2, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.012);\n        stopAudioTime2 = 0.3;\n        break;\n\n      case 32:\n        // Square Click\n        // w\n        gainNode.gain.value = 0;\n        stopAudioTime = 0; // s\n\n        oscillator.type = \"square\";\n        oscillator.frequency.setValueAtTime(333, start);\n        gainNode2.gain.setValueAtTime(0, start);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 4, start + 0.0016);\n        gainNode2.gain.linearRampToValueAtTime(0, start + 0.0032);\n        stopAudioTime2 = 0.0032;\n        break;\n\n      case 33: // Metronome Click\n\n      case 34:\n        // Metronome Bell\n        // w\n        source.playbackRate.setValueAtTime(0.17, start);\n        source.playbackRate.linearRampToValueAtTime(0.22, start + 0.01);\n        gainNode.gain.setValueAtTime(velocity * 1.5, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.015);\n        stopAudioTime = 0.3; // s\n\n        if (option.pitch == 34) {\n          oscillator.frequency.setValueAtTime(2040, start);\n          gainNode2.gain.setValueAtTime(velocity * 1, start);\n          gainNode2.gain.setTargetAtTime(0, start, 0.12);\n          stopAudioTime2 = 1.1;\n        } else {\n          gainNode2.gain.value = 0;\n          stopAudioTime2 = 0;\n        }\n\n        break;\n\n      case 82:\n        // Shaker\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(velocity * 0.5, start);\n        gainNode.gain.linearRampToValueAtTime(velocity, start + 0.02);\n        gainNode.gain.linearRampToValueAtTime(0, start + 0.07);\n        stopAudioTime = 0.07; // s\n\n        gainNode2.gain.value = 0;\n        stopAudioTime2 = 0;\n        break;\n\n      case 83:\n        // Jingle Bell\n        // w\n        source.playbackRate.value = 1;\n        gainNode.gain.setValueAtTime(0, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * 1.2, start + 0.015);\n        gainNode.gain.setTargetAtTime(0, start + 0.015, 0.06);\n        stopAudioTime = 0.5; // s\n\n        oscillator.type = \"triangle\";\n        oscillator.frequency.setValueAtTime(2709, start);\n        oscillator.frequency.linearRampToValueAtTime(2657, start + 0.3);\n        gainNode2.gain.setValueAtTime(0, start);\n        gainNode2.gain.linearRampToValueAtTime(velocity * 0.7, start + 0.025);\n        gainNode2.gain.setTargetAtTime(0, start + 0.025, 0.07);\n        stopAudioTime2 = 0.5;\n        break;\n\n      case 84:\n        // Bell Tree\n        // w s\n        var invert = false;\n        source.playbackRate.value = 1;\n\n        for (var i = 0; i < 28; i++) {\n          gainNode.gain.setValueAtTime(velocity * 0.1, start + i / 24 * 0.45);\n          gainNode.gain.setTargetAtTime(0, start + i / 24 * 0.45, 0.01);\n          oscillator.frequency.setValueAtTime(1380 * (1 + (invert ? (24 - i) / 24 : i / 24)), start + i / 24 * 0.45);\n          gainNode2.gain.setValueAtTime(velocity * (0.2 + i / 24), start + i / 24 * 0.45);\n          gainNode2.gain.setTargetAtTime(0, start + i / 24 * 0.45, i == 27 ? 0.2 : 0.01);\n        }\n\n        stopAudioTime = 0.5;\n        stopAudioTime2 = 1.5;\n        break;\n\n      case 85:\n        // Castanets\n        // w\n        source.playbackRate.setValueAtTime(0.35, start);\n        gainNode.gain.setValueAtTime(velocity * 1.3, start);\n        gainNode.gain.setTargetAtTime(0, start, 0.01);\n        stopAudioTime = 0.1; // s\n\n        oscillator.frequency.setValueAtTime(1730, start);\n        gainNode2.gain.setValueAtTime(velocity * 0.5, start);\n        gainNode2.gain.setTargetAtTime(0, start, 0.01);\n        stopAudioTime2 = 0.1;\n        break;\n\n      case 86: // Mute Surdo\n\n      case 87:\n        // Open Surdo\n        // w\n        source.playbackRate.setValueAtTime(0.020, start);\n        source.playbackRate.linearRampToValueAtTime(0.015, start + 0.5);\n        gainNode.gain.setValueAtTime(0, start);\n        gainNode.gain.linearRampToValueAtTime(velocity * 2, start + 0.005);\n        gainNode.gain.setTargetAtTime(0, start + 0.005, option.pitch == 86 ? 0.03 : 0.06);\n        stopAudioTime = 0.5; // s\n\n        oscillator.frequency.setValueAtTime(88, start);\n        oscillator.frequency.linearRampToValueAtTime(86, start + 0.3);\n        gainNode2.gain.setValueAtTime(velocity * 2.5, start);\n        gainNode2.gain.setTargetAtTime(0, start, option.pitch == 86 ? 0.1 : 0.3);\n        stopAudioTime2 = option.pitch == 86 ? 0.5 : 1.5;\n        break;\n\n      default:\n        source.playbackRate.value = option.pitch / 69 * 2;\n        stopAudioTime = 0.05;\n        stopAudioTime2 = 0;\n        break;\n    } // 同じドラムの音が重ならないようにする機能\n    // 同じドラムが次すぐ鳴る場合、次が鳴る前に止めて音が重ならないようにする（同時発音数の増加を軽減する）\n\n\n    if (!this.settings.isSameDrumSoundOverlap && nextSameNoteOnInterval != -1) {\n      if (stopAudioTime > nextSameNoteOnInterval) {\n        stopAudioTime = nextSameNoteOnInterval;\n      }\n\n      if (stopAudioTime2 > nextSameNoteOnInterval) {\n        stopAudioTime2 = nextSameNoteOnInterval;\n      }\n    } // ドラム音停止時間を設定\n\n\n    that.stopAudioNode(source, start + stopAudioTime, stopGainNode);\n    that.stopAudioNode(oscillator, start + stopAudioTime2, stopGainNode2); // ドラム停止時間を設定\n\n    option.drumStopTime = option.startTime + (stopAudioTime >= stopAudioTime2 ? stopAudioTime : stopAudioTime2); // 途中で曲停止する場合の処理を返す\n\n    return function () {\n      that.stopAudioNode(source, 0, stopGainNode, true);\n      that.stopAudioNode(oscillator, 0, stopGainNode2, true);\n    };\n  };\n\n  PicoAudio.prototype.createBaseNote = function (option, isDrum, isExpression, nonChannel, nonStop) {\n    var settings = this.settings;\n    var context = this.context;\n    var songStartTime = this.states.startTime;\n    var that = this;\n    var channel = nonChannel ? 0 : option.channel || 0;\n    var velocity = option.velocity * Number(nonChannel ? 1 : this.channels[channel][2] != null ? this.channels[channel][2] : 1) * settings.generateVolume;\n    var isGainValueZero = true;\n    if (velocity <= 0) return {\n      isGainValueZero: true\n    };\n    var expGainValue = velocity * ((option.expression ? option.expression[0].value : 100) / 127);\n    var expGainNode = context.createGain();\n    expGainNode.gain.value = expGainValue;\n\n    if (isExpression) {\n      option.expression ? option.expression.forEach(function (p) {\n        var v = velocity * (p.value / 127);\n        if (v > 0) isGainValueZero = false;\n        expGainNode.gain.setValueAtTime(v, p.time + songStartTime);\n      }) : false;\n    } else {\n      if (expGainValue > 0) {\n        isGainValueZero = false;\n      }\n    }\n\n    if (isGainValueZero) {\n      // 音量が常に0なら音を鳴らさない\n      return {\n        isGainValueZero: true\n      };\n    }\n\n    var start = option.startTime + songStartTime;\n    var stop = option.stopTime + songStartTime;\n    var pitch = settings.basePitch * Math.pow(Math.pow(2, 1 / 12), (option.pitch || 69) - 69);\n    var oscillator = !isDrum ? context.createOscillator() : context.createBufferSource();\n    var panNode = context.createStereoPanner ? context.createStereoPanner() : context.createPanner ? context.createPanner() : {\n      pan: {\n        setValueAtTime: function setValueAtTime() {}\n      }\n    };\n    var gainNode = context.createGain();\n    var stopGainNode = context.createGain();\n\n    if (!context.createStereoPanner && context.createPanner) {\n      // iOS, Old Browser\n      var panValue = option.pan && option.pan[0].value != 64 ? option.pan[0].value / 127 * 2 - 1 : 0;\n      if (panValue > 1.0) panValue = 1.0;\n      var panAngle = panValue * 90;\n      var panX = Math.sin(panAngle * (Math.PI / 180));\n      var panZ = -Math.cos(panAngle * (Math.PI / 180));\n      panNode.panningModel = \"equalpower\";\n      panNode.setPosition(panX, 0, panZ);\n    } else if (context.createStereoPanner) {\n      var panValue = option.pan && option.pan[0].value != 64 ? option.pan[0].value / 127 * 2 - 1 : 0;\n      if (panValue > 1.0) panValue = 1.0;\n      panNode.pan.value = panValue;\n    }\n\n    if (!isDrum) {\n      oscillator.type = option.type || \"sine\";\n      oscillator.detune.value = 0;\n      oscillator.frequency.value = pitch;\n      option.pitchBend ? option.pitchBend.forEach(function (p) {\n        oscillator.frequency.setValueAtTime(settings.basePitch * Math.pow(Math.pow(2, 1 / 12), option.pitch - 69 + p.value), p.time + songStartTime);\n      }) : false;\n    } else {\n      oscillator.loop = true;\n      oscillator.buffer = this.whitenoise;\n    }\n\n    if (context.createStereoPanner || context.createPanner) {\n      var firstPan = true;\n\n      if (context.createStereoPanner) {\n        option.pan ? option.pan.forEach(function (p) {\n          if (firstPan) {\n            firstPan = false;\n            return;\n          }\n\n          var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;\n          if (v > 1.0) v = 1.0;\n          panNode.pan.setValueAtTime(v, p.time + songStartTime);\n        }) : false;\n      } else if (context.createPanner) {\n        if (panNode.positionX) {\n          // Old Browser\n          option.pan ? option.pan.forEach(function (p) {\n            if (firstPan) {\n              firstPan = false;\n              return;\n            }\n\n            var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;\n            if (v > 1.0) v = 1.0;\n            var a = v * 90;\n            var x = Math.sin(a * (Math.PI / 180));\n            var z = -Math.cos(a * (Math.PI / 180));\n            panNode.positionX.setValueAtTime(x, p.time + songStartTime);\n            panNode.positionY.setValueAtTime(0, p.time + songStartTime);\n            panNode.positionZ.setValueAtTime(z, p.time + songStartTime);\n          }) : false;\n        } else {\n          // iOS\n          // setValueAtTimeが使えないためsetTimeoutでパンの動的変更\n          option.pan ? option.pan.forEach(function (p) {\n            if (firstPan) {\n              firstPan = false;\n              return;\n            }\n\n            var reservePan = setTimeout(function () {\n              that.clearFunc(\"pan\", reservePan);\n              var v = p.value == 64 ? 0 : p.value / 127 * 2 - 1;\n              if (v > 1.0) v = 1.0;\n              var a = v * 90;\n              var x = Math.sin(a * (Math.PI / 180));\n              var z = -Math.cos(a * (Math.PI / 180));\n              panNode.setPosition(x, 0, z);\n            }, (p.time + songStartTime - context.currentTime) * 1000);\n            that.pushFunc({\n              pan: reservePan,\n              stopFunc: function stopFunc() {\n                clearTimeout(reservePan);\n              }\n            });\n          }) : false;\n        }\n      }\n\n      oscillator.connect(panNode);\n      panNode.connect(expGainNode);\n    } else {\n      oscillator.connect(expGainNode);\n    }\n\n    expGainNode.connect(gainNode);\n    gainNode.connect(stopGainNode);\n    stopGainNode.connect(this.masterGainNode);\n    this.masterGainNode.connect(context.destination);\n\n    if (!isDrum && option.modulation && (option.modulation.length >= 2 || option.modulation[0].value > 0)) {\n      var modulationOscillator = context.createOscillator();\n      var modulationGainNode = context.createGain();\n      firstPan = true;\n      option.modulation ? option.modulation.forEach(function (p) {\n        if (firstPan) {\n          firstPan = false;\n          return;\n        }\n\n        var m = p.value / 127;\n        if (m > 1.0) m = 1.0;\n        modulationGainNode.gain.setValueAtTime(pitch * 10 / 440 * m, p.time + songStartTime);\n      }) : false;\n      var m = option.modulation ? option.modulation[0].value / 127 : 0;\n      if (m > 1.0) m = 1.0;\n      modulationGainNode.gain.value = pitch * 10 / 440 * m;\n      modulationOscillator.frequency.value = 6;\n      modulationOscillator.connect(modulationGainNode);\n      modulationGainNode.connect(oscillator.frequency);\n    }\n\n    if (this.settings.isReverb && option.reverb && (option.reverb.length >= 2 || option.reverb[0].value > 0)) {\n      var convolver = this.convolver;\n      var convolverGainNode = context.createGain();\n      firstPan = true;\n      option.reverb ? option.reverb.forEach(function (p) {\n        if (firstPan) {\n          firstPan = false;\n          return;\n        }\n\n        var r = p.value / 127;\n        if (r > 1.0) r = 1.0;\n        convolverGainNode.gain.setValueAtTime(r, p.time + songStartTime);\n      }) : false;\n      var r = option.reverb ? option.reverb[0].value / 127 : 0;\n      if (r > 1.0) r = 1.0;\n      convolverGainNode.gain.value = r;\n      gainNode.connect(stopGainNode);\n      stopGainNode.connect(convolverGainNode);\n      convolverGainNode.connect(convolver);\n    }\n\n    if (this.settings.isChorus && option.chorus && (option.chorus.length >= 2 || option.chorus[0].value > 0)) {\n      var chorusDelayNode = this.chorusDelayNode;\n      var chorusGainNode = context.createGain();\n      firstPan = true;\n      option.chorus ? option.chorus.forEach(function (p) {\n        if (firstPan) {\n          firstPan = false;\n          return;\n        }\n\n        var c = p.value / 127;\n        if (c > 1.0) c = 1.0;\n        chorusGainNode.gain.setValueAtTime(c, p.time + songStartTime);\n      }) : false;\n      var c = option.chorus ? option.chorus[0].value / 127 : 0;\n      if (c > 1.0) c = 1.0;\n      chorusGainNode.gain.value = c;\n      gainNode.connect(stopGainNode);\n      stopGainNode.connect(chorusGainNode);\n      chorusGainNode.connect(chorusDelayNode);\n    }\n\n    if (modulationOscillator) {\n      modulationOscillator.start(start);\n      this.stopAudioNode(modulationOscillator, stop, modulationGainNode);\n    }\n\n    oscillator.start(start);\n\n    if (!isDrum && !nonChannel && !nonStop) {\n      this.stopAudioNode(oscillator, stop, stopGainNode);\n    }\n\n    return {\n      start: start,\n      stop: stop,\n      pitch: pitch,\n      channel: channel,\n      velocity: velocity,\n      oscillator: oscillator,\n      panNode: panNode,\n      gainNode: gainNode,\n      stopGainNode: stopGainNode,\n      isGainValueZero: false\n    };\n  };\n\n  PicoAudio.prototype.startWebMIDI = function () {\n    var outputs;\n    var that = this;\n    if (!navigator.requestMIDIAccess) return; // 1回目：ブラウザにMIDIデバイスのフルコントロールを要求する(SysExの使用を要求)\n    // 2回目：MIDIデバイスのフルコントロールがブロックされたら、SysEx無しでMIDIアクセスを要求する\n\n    var sysEx = this.settings.WebMIDIPortSysEx;\n\n    var midiAccessSuccess = function midiAccessSuccess(midiAccess) {\n      outputs = midiAccess.outputs;\n      that.settings.WebMIDIPortOutputs = outputs;\n      var output;\n\n      if (that.settings.WebMIDIPort == -1) {\n        that.settings.WebMIDIPortOutputs.forEach(function (o) {\n          if (!output) output = o;\n        });\n      } else {\n        output = that.settings.WebMIDIPortOutputs.get(settings.WebMIDIPort);\n      }\n\n      that.settings.WebMIDIPortOutput = output;\n      that.settings.WebMIDIPortSysEx = sysEx;\n\n      if (output) {\n        output.open();\n        that.initStatus(); // リセットイベント（GMシステム・オン等）を送るため呼び出す\n      }\n\n      return outputs;\n    };\n\n    var midiAccessFailure = function midiAccessFailure(err) {\n      console.log(err);\n\n      if (sysEx) {\n        sysEx = false;\n        navigator.requestMIDIAccess({\n          sysex: sysEx\n        }).then(midiAccessSuccess).catch(midiAccessFailure);\n      }\n    };\n\n    navigator.requestMIDIAccess({\n      sysex: sysEx\n    }).then(midiAccessSuccess).catch(midiAccessFailure); // 終了時に鳴らしている音を切る\n\n    window.addEventListener('unload', function (e) {\n      for (var t = 0; t < 16; t++) {\n        that.settings.WebMIDIPortOutput.send([0xB0 + t, 120, 0]);\n\n        for (var i = 0; i < 128; i++) {\n          that.settings.WebMIDIPortOutput.send([0x80 + t, i, 0]);\n        }\n      }\n    });\n  };\n\n  PicoAudio.prototype.initStatus = function (isSongLooping, isLight) {\n    if (this.settings.isWebMIDI) {\n      // initStatus()連打の対策\n      if (this.states.webMIDIWaitState != null) return;\n    }\n\n    this.stop(isSongLooping);\n    var tempwebMIDIStopTime = this.states.webMIDIStopTime;\n    this.states = {\n      isPlaying: false,\n      startTime: 0,\n      stopTime: 0,\n      stopFuncs: [],\n      webMIDIWaitState: null,\n      webMIDIStopTime: 0,\n      playIndices: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n      updateBufTime: this.states.updateBufTime,\n      updateBufMaxTime: this.states.updateBufMaxTime,\n      updateIntervalTime: this.states.updateIntervalTime,\n      latencyLimitTime: this.states.latencyLimitTime,\n      noteOnAry: [],\n      noteOffAry: []\n    };\n    this.states.webMIDIStopTime = tempwebMIDIStopTime; // 値を初期化しない\n\n    if (this.settings.isWebMIDI && !isLight) {\n      if (isSongLooping) return;\n\n      if (this.settings.WebMIDIPortOutput == null) {\n        this.startWebMIDI();\n        return;\n      }\n\n      if (this.settings.WebMIDIPortSysEx) {\n        // GM1システム・オン\n        this.settings.WebMIDIPortOutput.send([0xF0, 0x7E, 0x7F, 0x09, 0x01, 0xF7]);\n      } else {\n        // SysExの使用が拒否されているので、できる限り設定値を初期値に戻す\n        for (var t = 0; t < 16; t++) {\n          this.settings.WebMIDIPortOutput.send([0xC0 + t, 0]);\n          this.settings.WebMIDIPortOutput.send([0xE0 + t, 0, 64]); // ピッチあたりのずれがひどくなる場合がある　よくわからない\n\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 100, 0]);\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 101, 0]);\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 6, 2]); //pitchbend\n\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 100, 1]);\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 96, 0]);\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 97, 64]); //tuning?\n\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 7, 100]); // volume\n\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 10, 64]); // pan\n\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 11, 127]); // expression\n          //this.settings.WebMIDIPortOutput.send([0xB0+t, 91, 40]); // リバーブ以外のエフェクトに設定される場合がありそうなのでコメントアウト\n          //this.settings.WebMIDIPortOutput.send([0xB0+t, 93, 0]); // コーラス以外のエフェクトに設定されるのか音が出なくなる場合があるのでコメントアウト\n\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 98, 0]);\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 99, 0]); //this.settings.WebMIDIPortOutput.send([0xB0+t, 121, 0]);\n\n          this.settings.WebMIDIPortOutput.send([0xB0 + t, 122, 0]);\n        }\n      }\n    }\n  };\n\n  PicoAudio.prototype.stop = function (isSongLooping) {\n    var states = this.states;\n    var that = this;\n    if (states.isPlaying == false) return;\n    states.isPlaying = false;\n    states.stopTime = this.context.currentTime;\n    states.stopFuncs.forEach(function (n) {\n      n.stopFunc();\n    });\n    states.stopFuncs = [];\n    states.playIndices.forEach(function (n, i, ary) {\n      ary[i] = 0;\n    });\n    states.noteOnAry = [];\n    states.noteOffAry = [];\n\n    if (this.settings.isWebMIDI) {\n      if (isSongLooping) return;\n      if (this.settings.WebMIDIPortOutput == null) return;\n      states.webMIDIStopTime = this.context.currentTime;\n      setTimeout(function () {\n        for (var t = 0; t < 16; t++) {\n          that.settings.WebMIDIPortOutput.send([0xB0 + t, 120, 0]);\n        }\n      }, 1000);\n    }\n\n    this.trigger.stop();\n    this.fireEvent('stop');\n  };\n\n  PicoAudio.prototype.play = function (isSongLooping) {\n    var context = this.context;\n    var settings = this.settings;\n    var trigger = this.trigger;\n    var states = this.states;\n    var that = this;\n    if (states.isPlaying == true) return;\n\n    if (settings.isWebMIDI && !isSongLooping) {\n      // Web MIDI API使用時はstop()から800ms程待機すると音がバグりにくい\n      if (states.webMIDIWaitState != \"completed\") {\n        if (states.webMIDIWaitState != \"waiting\") {\n          // play()連打の対策\n          // stop()から800ms後にplay()を実行\n          states.webMIDIWaitState = \"waiting\";\n          var waitTime = 1000 - (context.currentTime - states.webMIDIStopTime) * 1000;\n          if (states.webMIDIStopTime == 0) waitTime = 1000; // MIDI Portをopenして最初に呼び出すときも少し待つ\n\n          setTimeout(function () {\n            that.states.webMIDIWaitState = \"completed\";\n            that.states.isPlaying = false;\n            that.play();\n          }, waitTime);\n        }\n\n        return;\n      } else {\n        states.webMIDIWaitState = null;\n      }\n    }\n\n    var currentTime = this.context.currentTime;\n    this.isPlayed = true;\n    states.isPlaying = true;\n    states.startTime = !states.startTime && !states.stopTime ? currentTime : states.startTime + currentTime - states.stopTime;\n    states.stopFuncs = []; // 冒頭の余白をスキップ\n\n    if (this.settings.isSkipBeginning) {\n      var firstNoteOnTime = this.firstNoteOnTime;\n\n      if (-states.startTime + currentTime < firstNoteOnTime) {\n        this.setStartTime(firstNoteOnTime + states.startTime - currentTime);\n      }\n    } // 曲終了コールバックを予約\n\n\n    var reserveSongEnd;\n\n    var reserveSongEndFunc = function reserveSongEndFunc() {\n      that.clearFunc(\"rootTimeout\", reserveSongEnd);\n      var finishTime = that.settings.isCC111 && that.cc111Time != -1 ? that.lastNoteOffTime : that.getTime(Number.MAX_SAFE_INTEGER);\n\n      if (finishTime - context.currentTime + states.startTime <= 0) {\n        // 予定の時間以降に曲終了\n        trigger.songEnd();\n        that.onSongEnd();\n        that.fireEvent('songEnd');\n      } else {\n        // 処理落ちしたりしてまだ演奏中の場合、1ms後に曲終了コールバックを呼び出すよう予約\n        reserveSongEnd = setTimeout(reserveSongEndFunc, 1);\n        that.pushFunc({\n          rootTimeout: reserveSongEnd,\n          stopFunc: function stopFunc() {\n            clearTimeout(reserveSongEnd);\n          }\n        });\n      }\n    };\n\n    var finishTime = this.settings.isCC111 && this.cc111Time != -1 ? this.lastNoteOffTime : this.getTime(Number.MAX_SAFE_INTEGER);\n    var reserveSongEndTime = (finishTime - context.currentTime + states.startTime) * 1000;\n    reserveSongEnd = setTimeout(reserveSongEndFunc, reserveSongEndTime);\n    that.pushFunc({\n      rootTimeout: reserveSongEnd,\n      stopFunc: function stopFunc() {\n        clearTimeout(reserveSongEnd);\n      }\n    });\n    var updateNowTime = performance.now();\n    var pPreTime = performance.now(); // previous performance.now()\n\n    var cPreTime = context.currentTime * 1000; // previous AudioContext.currentTime\n\n    var pTimeSum = 0;\n    var cTimeSum = 0;\n    var cnt = 0;\n    trigger.play();\n    this.fireEvent('play');\n\n    (function updateNote(updatePreTime) {\n      var updateNowTime = performance.now();\n      var updateBufTime = updateNowTime - updatePreTime; // サウンドが重くないか監視（フリーズ対策）\n\n      var pTime = updateNowTime;\n      var cTime = context.currentTime * 1000;\n      pTimeSum += pTime - pPreTime;\n      cTimeSum += cTime - cPreTime;\n      pPreTime = pTime;\n      cPreTime = cTime;\n      var latencyTime = pTimeSum - cTimeSum;\n      that.states.latencyTime = latencyTime;\n\n      if (latencyTime >= 100) {\n        // currentTimeが遅い（サウンドが重い）\n        that.states.latencyLimitTime += latencyTime;\n        cTimeSum += 100;\n      } else if (latencyTime <= -100) {\n        // currentTimeが速い（誤差）\n        cTimeSum = pTimeSum;\n      } else {\n        if (that.states.latencyLimitTime > 0) {\n          // currentTimeが丁度いい\n          that.states.latencyLimitTime -= updateBufTime * 0.04;\n          if (that.states.latencyLimitTime < 0) that.states.latencyLimitTime = 0;\n        }\n      } // ノートを先読み度合いを自動調整（予約しすぎると重くなる）\n\n\n      that.states.updateIntervalTime = updateBufTime;\n      updateBufTime += that.isFirefox() && !that.isAndroid() ? 12 : 8;\n\n      if (that.states.updateBufTime < updateBufTime) {\n        that.states.updateBufTime = updateBufTime;\n      } else {\n        // 先読み量を少しずつ減らす\n        that.states.updateBufTime -= that.states.updateBufTime * 0.001;\n\n        if (that.states.updateBufTime > 100) {\n          that.states.updateBufTime -= that.states.updateBufTime * 0.01;\n        }\n\n        if (that.states.updateBufMaxTime > 150) {\n          that.states.updateBufMaxTime -= that.states.updateBufMaxTime * 0.002;\n        }\n\n        if (that.states.updateBufMaxTime > 10 && that.states.updateBufMaxTime < 140) {\n          that.states.updateBufMaxTime += that.states.updateBufMaxTime * 0.003;\n        }\n      }\n\n      if (that.states.updateBufTime > that.states.updateBufMaxTime) {\n        if (updateBufTime >= 900 && that.states.latencyLimitTime <= 150) {\n          // バックグラウンドっぽくて重くない場合、バックグラウンド再生\n          that.states.updateBufMaxTime += updateBufTime;\n        } else {\n          // 通常\n          var tempTime = updateBufTime - that.states.updateBufMaxTime;\n          that.states.updateBufTime = that.states.updateBufMaxTime;\n\n          if (that.states.updateBufMaxTime < 10) {\n            that.states.updateBufTime = that.states.updateBufMaxTime;\n            that.states.updateBufMaxTime *= 1.25;\n          } else {\n            that.states.updateBufMaxTime += tempTime / 2;\n          }\n        }\n\n        if (that.states.updateBufMaxTime > 1100) that.states.updateBufMaxTime = 1100;\n      } // サウンドが重すぎる\n\n\n      if (that.states.latencyLimitTime > 200) {\n        cTimeSum = pTimeSum;\n        that.states.latencyLimitTime -= 5;\n        if (that.states.latencyLimitTime > 1000) that.states.latencyLimitTime = 1000; // ノート先読みをかなり小さくする（フリーズ対策）\n\n        that.states.updateBufMaxTime = 1;\n        that.states.updateBufTime = 1;\n        updateBufTime = 1;\n      } // 再生処理\n\n\n      for (var ch = 0; ch < 16; ch++) {\n        var notes = that.playData.channels[ch].notes;\n        var idx = that.states.playIndices[ch];\n\n        for (; idx < notes.length; idx++) {\n          var note = notes[idx];\n          var curTime = context.currentTime - states.startTime; // 終わったノートは演奏せずにスキップ\n\n          if (curTime >= note.stopTime) continue;\n          if (cnt == 0 && curTime > note.startTime + 0.05) continue; // （シークバーで途中から再生時）startTimeが過ぎたものは鳴らさない\n          // AudioParam.setValueAtTime()等でマイナスが入るとエラーになるので対策\n\n          if (curTime + note.startTime < 0) continue; // 演奏開始時間 - 先読み時間(ノート予約) になると演奏予約or演奏開始\n\n          if (curTime < note.startTime - that.states.updateBufTime / 1000) break;\n\n          if (!settings.isWebMIDI) {\n            // 予約ノート数が急激に増えそうな時、先読み量を小さくしておく\n            if (that.states.stopFuncs.length >= 350 && that.states.updateBufTime < 1000) {\n              that.states.updateBufTime = that.isFirefox() && !that.isAndroid() ? 12 : 8;\n              that.states.updateBufMaxTime = that.states.updateBufTime;\n            } // Retro Mode\n\n\n            if (that.settings.maxPoly != -1 || that.settings.maxPercPoly != -1) {\n              var polyCnt = 0,\n                  percCnt = 0;\n              that.states.stopFuncs.forEach(function (tar) {\n                if (!tar.note) return;\n\n                if (tar.note.channel != 9) {\n                  if (note.start >= tar.note.start && note.start < tar.note.stop) {\n                    polyCnt++;\n                  }\n                } else {\n                  if (note.start == tar.note.start) {\n                    percCnt++;\n                  }\n                }\n              });\n\n              if (note.channel != 9 && polyCnt >= that.settings.maxPoly || note.channel == 9 && percCnt >= that.settings.maxPercPoly) {\n                continue;\n              }\n            } // Create Note\n\n\n            var stopFunc = note.channel != 9 ? that.createNote(note) : that.createPercussionNote(note);\n            if (!stopFunc) continue; // 無音などの場合\n\n            that.pushFunc({\n              note: note,\n              stopFunc: stopFunc\n            });\n          }\n\n          that.states.noteOnAry.push(note);\n        }\n\n        that.states.playIndices[ch] = idx;\n      }\n\n      var noteOnAry = that.states.noteOnAry;\n      var noteOffAry = that.states.noteOffAry; // noteOnの時間になったか監視\n\n      for (var i = 0; i < noteOnAry.length; i++) {\n        var tempNote = noteOnAry[i];\n        var nowTime = context.currentTime - states.startTime;\n\n        if (tempNote.startTime - nowTime <= 0) {\n          // noteOnAry.splice(i, 1); の高速化\n          if (i == 0) noteOnAry.shift();else if (i == noteOnAry.length - 1) noteOnAry.pop();else noteOnAry.splice(i, 1);\n          noteOffAry.push(tempNote); // noteOn\n\n          if (trigger.isNoteTrigger) trigger.noteOn(tempNote);\n          i--;\n        }\n      } // noteOffの時間になったか監視\n\n\n      for (var i = 0; i < noteOffAry.length; i++) {\n        var tempNote = noteOffAry[i];\n        var nowTime = context.currentTime - states.startTime;\n\n        if (tempNote.channel != 9 && tempNote.stopTime - nowTime <= 0 || tempNote.channel == 9 && tempNote.drumStopTime - nowTime <= 0) {\n          // noteOffAry.splice(i, 1); の高速化\n          if (i == 0) noteOffAry.shift();else if (i == noteOffAry.length - 1) noteOffAry.pop();else noteOffAry.splice(i, 1);\n          that.clearFunc(\"note\", tempNote); // noteOff\n\n          if (trigger.isNoteTrigger) trigger.noteOff(tempNote);\n          i--;\n        }\n      }\n\n      if (settings.isWebMIDI && settings.WebMIDIPortOutput != null) {\n        var messages = that.playData.messages;\n        var smfData = that.playData.smfData;\n        var idx = that.states.playIndices[16];\n\n        for (; idx < messages.length; idx++) {\n          var message = messages[idx];\n          var curTime = context.currentTime - states.startTime; // 終わったノートは演奏せずにスキップ\n\n          if (curTime > message.time + 1) continue; // 演奏開始時間 - 先読み時間(ノート予約) になると演奏予約or演奏開始\n\n          if (curTime < message.time - 1) break;\n          var pLen = message.smfPtrLen;\n          var p = message.smfPtr;\n          var time = message.time;\n          var state = smfData[p];\n\n          if (state != 0xff) {\n            try {\n              if (state == 0xF0 || state == 0xF7) {\n                if (settings.WebMIDIPortSysEx) {\n                  // 長さ情報を取り除いて純粋なSysExメッセージにする\n                  var lengthAry = that.variableLengthToInt(smfData, p + 1, p + 1 + 4);\n                  var sysExStartP = p + 1 + lengthAry[1];\n                  var sysExEndP = sysExStartP + lengthAry[0];\n                  var webMIDIMes = new Uint8Array(1 + lengthAry[0]);\n                  webMIDIMes[0] = state;\n                  var size = sysExEndP - sysExStartP;\n\n                  for (var i = 0; i < size; i++) {\n                    webMIDIMes[i + 1] = smfData[sysExStartP + i];\n                  }\n\n                  settings.WebMIDIPortOutput.send(webMIDIMes, (time - context.currentTime + window.performance.now() / 1000 + states.startTime) * 1000);\n                }\n              } else {\n                var sendMes = [];\n\n                for (var i = 0; i < pLen; i++) {\n                  sendMes.push(smfData[p + i]);\n                }\n\n                settings.WebMIDIPortOutput.send(sendMes, (time - context.currentTime + window.performance.now() / 1000 + states.startTime) * 1000);\n              }\n            } catch (e) {\n              console.log(e, p, pLen, time, state);\n            }\n          }\n        }\n\n        that.states.playIndices[16] = idx;\n      }\n\n      if (cnt == 0) {\n        var reserve = setInterval(function () {\n          updateNowTime = updateNote(updateNowTime);\n        }, 1);\n\n        (function (reserve) {\n          that.pushFunc({\n            rootTimeout: reserve,\n            stopFunc: function stopFunc() {\n              clearInterval(reserve);\n            }\n          });\n        })(reserve);\n      }\n\n      cnt++;\n      return updateNowTime;\n    })(updateNowTime);\n  };\n\n  PicoAudio.prototype.setData = function (data) {\n    if (this.debug) {\n      var syoriTimeS = performance.now();\n    }\n\n    if (this.states.isPlaying) this.stop();\n    this.playData = data;\n    this.settings.resolution = data.header.resolution;\n    this.settings.tempo = data.tempo || 120;\n    this.tempoTrack = data.tempoTrack;\n    this.cc111Time = data.cc111Time;\n    this.firstNoteOnTiming = data.firstNoteOnTiming;\n    this.lastNoteOffTiming = data.lastNoteOffTiming;\n    this.firstNoteOnTime = data.firstNoteOnTime;\n    this.lastNoteOffTime = data.lastNoteOffTime;\n    this.initStatus();\n\n    if (this.debug) {\n      var syoriTimeE = performance.now();\n      console.log(\"setData time\", syoriTimeE - syoriTimeS);\n    }\n\n    return this;\n  };\n\n  PicoAudio.prototype.getChannels = function () {\n    return this.channels;\n  };\n\n  PicoAudio.prototype.setChannels = function (channels) {\n    var that = this;\n    channels.forEach(function (channel, idx) {\n      that.channels[idx] = channel;\n    });\n  };\n\n  PicoAudio.prototype.initChannels = function () {\n    for (var i = 0; i < 16; i++) {\n      this.channels[i] = [0, 0, 1];\n    }\n  };\n\n  PicoAudio.prototype.getMasterVolume = function () {\n    return this.settings.masterVolume;\n  };\n\n  PicoAudio.prototype.setMasterVolume = function (volume) {\n    this.settings.masterVolume = volume;\n    this.masterGainNode.gain.value = this.settings.masterVolume;\n  };\n\n  PicoAudio.prototype.isLoop = function () {\n    return this.settings.loop;\n  };\n\n  PicoAudio.prototype.setLoop = function (loop) {\n    this.settings.loop = loop;\n  };\n\n  PicoAudio.prototype.isWebMIDI = function () {\n    return this.settings.isWebMIDI;\n  };\n\n  PicoAudio.prototype.setWebMIDI = function (enable) {\n    this.settings.isWebMIDI = enable;\n  };\n\n  PicoAudio.prototype.isCC111 = function () {\n    return this.settings.isCC111;\n  };\n\n  PicoAudio.prototype.setCC111 = function (enable) {\n    this.settings.isCC111 = enable;\n  };\n\n  PicoAudio.prototype.setStartTime = function (offset) {\n    this.states.startTime -= offset;\n  };\n\n  PicoAudio.prototype.setOnSongEndListener = function (listener) {\n    this.onSongEndListener = listener;\n  };\n\n  PicoAudio.prototype.onSongEnd = function () {\n    if (this.onSongEndListener) {\n      var isStopFunc = this.onSongEndListener();\n      if (isStopFunc) return;\n    }\n\n    if (this.settings.loop) {\n      this.initStatus(true);\n\n      if (this.settings.isCC111 && this.cc111Time != -1) {\n        this.setStartTime(this.cc111Time);\n      }\n\n      this.play(true);\n    }\n  };\n\n  PicoAudio.prototype.isReverb = function () {\n    return this.settings.isReverb;\n  };\n\n  PicoAudio.prototype.setReverb = function (enable) {\n    this.settings.isReverb = enable;\n  };\n\n  PicoAudio.prototype.getReverbVolume = function () {\n    return this.settings.reverbVolume;\n  };\n\n  PicoAudio.prototype.setReverbVolume = function (volume) {\n    this.settings.reverbVolume = volume;\n  };\n\n  PicoAudio.prototype.isChorus = function () {\n    return this.settings.isChorus;\n  };\n\n  PicoAudio.prototype.setChorus = function (enable) {\n    this.settings.isChorus = enable;\n  };\n\n  PicoAudio.prototype.getChorusVolume = function () {\n    return this.settings.chorusVolume;\n  };\n\n  PicoAudio.prototype.setChorusVolume = function (volume) {\n    this.settings.chorusVolume = volume;\n  };\n\n  PicoAudio.prototype.isAndroid = function () {\n    var u = navigator.userAgent.toLowerCase();\n    return u.indexOf(\"android\") != -1 && u.indexOf(\"windows\") == -1;\n  };\n\n  PicoAudio.prototype.isFirefox = function () {\n    var u = navigator.userAgent.toLowerCase();\n    return u.indexOf(\"firefox\") != -1;\n  };\n\n  PicoAudio.prototype.isArmv7l = function () {\n    // Raspberry Pi\n    var u = navigator.userAgent.toLowerCase();\n    return u.indexOf(\"armv7l\") != -1;\n  };\n\n  PicoAudio.prototype.measurePerformanceReverb = function () {\n    // 0.5秒パフォーマンス計測して、リバーブONにするか判断する\n    var max = 500000; // 0.5秒以内にここまで計算できればリバーブON\n\n    var startTime = performance.now();\n\n    for (var i = 0; i < max; i++) {\n      if (performance.now() - startTime >= 500) break;\n    }\n\n    if (this.debug) {\n      console.log(\"measurePerformanceReverb\", i, performance.now() - startTime);\n    }\n\n    if (i < max) return false;\n    return true;\n  };\n\n  PicoAudio.prototype.getTime = function (timing) {\n    var imin = 0;\n    var imax = this.tempoTrack.length - 1;\n    var imid = -1;\n\n    if (this.tempoTrack && this.tempoTrack.length >= 1) {\n      if (timing >= this.tempoTrack[this.tempoTrack.length - 1].timing) {\n        return this.tempoTrack[this.tempoTrack.length - 1].time;\n      }\n\n      while (true) {\n        imid = Math.floor(imin + (imax - imin) / 2);\n        var tempTiming = this.tempoTrack[imid].timing;\n\n        if (timing < tempTiming) {\n          imax = imid - 1;\n        } else if (timing > tempTiming) {\n          imin = imid + 1;\n        } else {\n          break;\n        }\n\n        if (imin > imax) {\n          if (timing < tempTiming) imid--;\n          break;\n        }\n      }\n    }\n\n    if (imid >= 0) {\n      var tempoObj = this.tempoTrack[imid];\n      var time = tempoObj.time;\n      var baseTiming = tempoObj.timing;\n      var tempo = tempoObj.value;\n    } else {\n      var time = 0;\n      var baseTiming = 0;\n      var tempo = 120;\n    }\n\n    time += 60 / tempo / this.settings.resolution * (timing - baseTiming);\n    return time;\n  };\n\n  PicoAudio.prototype.getTiming = function (time) {\n    var imin = 0;\n    var imax = this.tempoTrack.length - 1;\n    var imid = -1;\n\n    if (this.tempoTrack && this.tempoTrack.length >= 1) {\n      if (time >= this.tempoTrack[this.tempoTrack.length - 1].time) {\n        return this.tempoTrack[this.tempoTrack.length - 1].timing;\n      }\n\n      while (true) {\n        imid = Math.floor(imin + (imax - imin) / 2);\n        var tempTime = this.tempoTrack[imid].time;\n\n        if (time < tempTime) {\n          imax = imid - 1;\n        } else if (time > tempTime) {\n          imin = imid + 1;\n        } else {\n          break;\n        }\n\n        if (imin > imax) {\n          if (time < tempTime) imid--;\n          break;\n        }\n      }\n    }\n\n    if (imid >= 0) {\n      var tempoObj = this.tempoTrack[imid];\n      var baseTime = tempoObj.time;\n      var timing = tempoObj.timing;\n      var tempo = tempoObj.value;\n    } else {\n      var baseTime = 0;\n      var timing = 0;\n      var tempo = 120;\n    }\n\n    timing += (time - baseTime) / (60 / tempo / this.settings.resolution);\n    return timing;\n  };\n\n  PicoAudio.prototype.parseSMF = function (_smf) {\n    if (this.debug) {\n      console.log(_smf);\n      var syoriTimeS = performance.now();\n    }\n\n    var that = this;\n    var smf = new Uint8Array(_smf); // smf配列はデータ上書きするので_smfをディープコピーする\n\n    if (smf[0] != 77 || smf[1] != 84 || smf[2] != 104 || smf[3] != 100) return \"Not Sandard MIDI File.\";\n    var data = new Object();\n    var p = 4;\n    var header = new Object();\n    header.size = this.getInt(smf, 4, 8);\n    header.format = smf[9];\n    header.trackcount = this.getInt(smf, 10, 12);\n    header.timemanage = smf[12];\n    header.resolution = this.getInt(smf, 12, 14); // TODO 0除算防止。15bit目1のとき、https://sites.google.com/site/yyagisite/material/smfspec#ConductorTrack\n\n    p += 4 + header.size;\n    var tempoTrack = new Array();\n    var beatTrack = new Array();\n    var channels = new Array();\n    var cc111Tick = -1;\n    var cc111Time = -1;\n    var firstNoteOnTiming = Number.MAX_SAFE_INTEGER; // 最初のノートオンのTick\n\n    var firstNoteOnTime = Number.MAX_SAFE_INTEGER;\n    var lastNoteOffTiming = 0; // 最後のノートオフのTick\n\n    var lastNoteOffTime = 0;\n    var chSize = this.settings.isWebMIDI ? 17 : 16;\n\n    for (var i = 0; i < chSize; i++) {\n      var channel = new Object();\n      channels.push(channel); // smfを読む順番を記録した索引配列を作る\n      // 型付き配列をリスト構造のように使う（リスト構造にすることで挿入処理を高速化する）\n      // [tick, smfMesLength, smfPtr, nextIndicesPtr, ...]\n\n      channel.indices = new Int32Array(Math.floor(smf.length / 8));\n      channel.indicesLength = 0;\n      channel.indicesHead = -1; // 先頭のポインタ\n\n      channel.indicesFoot = 0; // 末尾のポインタ\n\n      channel.indicesCur = 0; // 現在のinsert用ポインタ\n\n      channel.indicesPre = 0; // 前回のinsert用ポインタ\n\n      channel.notes = [];\n    }\n\n    if (this.debug) {\n      var syoriTimeS1_1 = performance.now();\n    }\n\n    var songLength = 0;\n    if (this.settings.isWebMIDI) var messages = [];\n\n    for (var t = 0; t < header.trackcount; t++) {\n      if (smf[p] != 77 || smf[p + 1] != 84 || smf[p + 2] != 114 || smf[p + 3] != 107) return \"Irregular SMF.\";\n      p += 4;\n      var endPoint = p + 4 + this.getInt(smf, p, p + 4);\n      p += 4;\n      var tick = 0;\n      var tempo = 120;\n      var tempoCurTick = 0;\n      var tempoCurTime = 0;\n      var lastState = 1;\n\n      while (p < endPoint) {\n        // DeltaTime\n        if (lastState != null) {\n          var lengthAry = this.variableLengthToInt(smf, p, p + 5);\n          var dt = lengthAry[0];\n          tick += dt;\n          p += lengthAry[1];\n        } // WebMIDIAPI\n\n\n        if (this.settings.isWebMIDI) {\n          var cashP = p;\n          var time = 60 / tempo / header.resolution * (tick - tempoCurTick) + tempoCurTime;\n        } // Events\n\n\n        switch (Math.floor(smf[p] / 0x10)) {\n          case 0x8: // Note OFF - 8[ch], Pitch, Velocity\n\n          case 0x9: // Note ON - 9[ch], Pitch, Velocity\n\n          case 0xA: // Polyfonic Key Pressure - A[ch], Pitch?, Velocity?\n\n          case 0xB: // Control Change - B[ch],,\n\n          case 0xE:\n            // PitchBend Change - E[ch],,\n            // チャンネル毎に仕分けた後に解析する\n            lastState = smf[p];\n            var ch = channels[lastState & 0x0F];\n            this.chIndicesSplice(ch, tick, p, 3); // デルタタイムの順番になるようにリスト配列に挿入\n\n            p += 3;\n            break;\n\n          case 0xC: // Program Change - C[ch],\n\n          case 0xD:\n            // Channel Pre - D[ch],\n            // チャンネル毎に仕分けた後に解析する\n            lastState = smf[p];\n            var ch = channels[lastState & 0x0F];\n            this.chIndicesSplice(ch, tick, p, 2); // デルタタイムの順番になるようにリスト配列に挿入\n\n            p += 2;\n            break;\n          // SysEx Events or Meta Events - F[ch], ...\n\n          case 0xF:\n            {\n              //lastState = smf[p]; <- ランニングナントカは無いらしい\n              switch (smf[p]) {\n                case 0xF0:\n                case 0xF7:\n                  // SysEx Events\n                  var lengthAry = this.variableLengthToInt(smf, p + 1, p + 1 + 4); // Master Volume\n                  // 0xF0, size, 0x7f, 0x7f, 0x04, 0x01, 0xNN, volume, 0xF7\n\n                  if (lengthAry[0] >= 7 && smf[p + 2] == 0x7f && smf[p + 3] == 0x7f && smf[p + 4] == 0x04 && smf[p + 5] == 0x01) {\n                    // 全チャンネルにMasterVolumeメッセージを挿入する\n                    for (var i = 0; i < 16; i++) {\n                      var ch = channels[i];\n                      this.chIndicesSplice(ch, tick, p, lengthAry[0]); // デルタタイムの順番になるように配列に挿入\n                    }\n                  }\n\n                  p += 1 + lengthAry[1] + lengthAry[0];\n                  break;\n\n                case 0xF1:\n                  p += 2;\n                  break;\n\n                case 0xF2:\n                  p += 3;\n                  break;\n\n                case 0xF3:\n                  p += 2;\n                  break;\n\n                case 0xF6:\n                case 0xF8:\n                case 0xFA:\n                case 0xFB:\n                case 0xFC:\n                case 0xFE:\n                  p += 1;\n                  break;\n\n                case 0xFF:\n                  {\n                    // Meta Events\n                    switch (smf[p + 1]) {\n                      case 0x00:\n                      case 0x01:\n                      case 0x02:\n                      case 0x03:\n                      case 0x04:\n                      case 0x05:\n                      case 0x06:\n                      case 0x07:\n                      case 0x20:\n                        break;\n\n                      case 0x2F:\n                        tick += (this.settings.isSkipEnding ? 0 : header.resolution) - dt;\n                        break;\n                      // Tempo\n\n                      case 0x51:\n                        // 全チャンネルにTempoメッセージを挿入する\n                        for (var i = 0; i < 16; i++) {\n                          var ch = channels[i];\n                          this.chIndicesSplice(ch, tick, p, 6); // デルタタイムの順番になるように配列に挿入\n                        }\n\n                        tempoCurTime += 60 / tempo / header.resolution * (tick - tempoCurTick);\n                        tempoCurTick = tick;\n                        tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);\n                        tempoTrack.push({\n                          timing: tick,\n                          time: tempoCurTime,\n                          value: tempo\n                        });\n                        break;\n\n                      case 0x54:\n                        break;\n                      // Beat\n\n                      case 0x58:\n                        beatTrack.push({\n                          timing: tick,\n                          value: [smf[p + 3], Math.pow(2, smf[p + 4])]\n                        });\n                        break;\n\n                      case 0x59:\n                      case 0x7F:\n                        break;\n                    }\n\n                    var lengthAry = this.variableLengthToInt(smf, p + 2, p + 2 + 4);\n                    p += 2 + lengthAry[1] + lengthAry[0];\n                    break;\n                  }\n              }\n\n              break;\n            }\n\n          default:\n            {\n              if (lastState == null) return \"Irregular SMF.\";\n              p--;\n              smf[p] = lastState; // 上書き\n\n              lastState = null;\n            }\n        } // WebMIDIAPI\n\n\n        if (this.settings.isWebMIDI) {\n          if (lastState != null) {\n            this.chIndicesSplice(channels[16], tick, cashP, p - cashP);\n          }\n        }\n      }\n\n      if (!this.settings.isSkipEnding && songLength < tick) songLength = tick; // リスト配列のポインタを初期化\n\n      for (var i = 0; i < channels.length; i++) {\n        channels[i].indicesCur = channels[i].indicesHead;\n        channels[i].indicesPre = channels[i].indicesHead;\n      }\n    }\n\n    if (this.debug) {\n      var syoriTimeS2 = performance.now();\n    } // Midi Events (0x8n - 0xEn) parse\n\n\n    for (var ch = 0; ch < 16; ch++) {\n      var channel = channels[ch];\n      var dataEntry = 2;\n      var pitchBend = 0;\n      var pan = 64;\n      var expression = 127;\n      var velocity = 100;\n      var modulation = 0;\n      var hold = 0;\n      var reverb = this.isTonyu2 ? 0 : 10;\n      var chorus = 0;\n      var nrpnLsb = 127;\n      var nrpnMsb = 127;\n      var rpnLsb = 127;\n      var rpnMsb = 127;\n      var instrument = 0;\n      var masterVolume = 127;\n      var tempo = 120;\n      var tempoCurTick = 0;\n      var tempoCurTime = 0;\n      var nowNoteOnIdxAry = [];\n      var indIdx = channel.indicesHead;\n      var indices = channel.indices;\n      var nextNoteOnAry = new Array(128);\n\n      while (indIdx != -1) {\n        var tick = indices[indIdx];\n        var p = indices[indIdx + 2];\n        var nextIdx = indices[indIdx + 3];\n        var time = 60 / tempo / header.resolution * (tick - tempoCurTick) + tempoCurTime; // Events\n\n        switch (Math.floor(smf[p] / 0x10)) {\n          // Note OFF - 8[ch], Pitch, Velocity\n          case 0x8:\n            nowNoteOnIdxAry.some(function (idx, i) {\n              var note = channel.notes[idx];\n\n              if (note.pitch == smf[p + 1] && note.stop == null) {\n                if (hold >= that.settings.holdOnValue) {\n                  if (note.holdBeforeStop == null) {\n                    note.holdBeforeStop = [{\n                      timing: tick,\n                      time: time,\n                      value: hold\n                    }];\n                  }\n                } else {\n                  note.stop = tick;\n                  note.stopTime = time; // nowNoteOnIdxAry.splice(i, 1); を軽量化\n\n                  if (i == nowNoteOnIdxAry.length - 1) nowNoteOnIdxAry.pop();else if (i == 0) nowNoteOnIdxAry.shift();else nowNoteOnIdxAry.splice(i, 1);\n                }\n\n                if (tick > lastNoteOffTiming) {\n                  lastNoteOffTiming = tick;\n                  lastNoteOffTime = time;\n                }\n\n                return true;\n              }\n            });\n            break;\n          // Note ON - 9[ch], Pitch, Velocity\n\n          case 0x9:\n            if (smf[p + 2] != 0) {\n              that.settings.resolution = header.resolution;\n              var note = {\n                start: tick,\n                stop: null,\n                startTime: time,\n                stopTime: null,\n                pitch: smf[p + 1],\n                pitchBend: [{\n                  timing: tick,\n                  time: time,\n                  value: pitchBend\n                }],\n                pan: [{\n                  timing: tick,\n                  time: time,\n                  value: pan\n                }],\n                expression: [{\n                  timing: tick,\n                  time: time,\n                  value: expression * (masterVolume / 127)\n                }],\n                velocity: smf[p + 2] / 127 * (velocity / 127),\n                modulation: [{\n                  timing: tick,\n                  time: time,\n                  value: modulation\n                }],\n                holdBeforeStop: null,\n                reverb: [{\n                  timing: tick,\n                  time: time,\n                  value: reverb\n                }],\n                chorus: [{\n                  timing: tick,\n                  time: time,\n                  value: chorus\n                }],\n                instrument: instrument,\n                channel: ch,\n                nextSameNoteOnInterval: -1,\n                drumStopTime: 2 // 再生時に使う\n\n              }; // 前回鳴っていた同音ノートに次のノートオン時間を入れる\n\n              var prevNote = nextNoteOnAry[smf[p + 1]];\n\n              if (prevNote) {\n                prevNote.nextSameNoteOnInterval = time - prevNote.startTime;\n              }\n\n              nextNoteOnAry[smf[p + 1]] = note; // If this note is NoteOn, change to NoteOFF.\n\n              nowNoteOnIdxAry.some(function (idx, i) {\n                var note = channel.notes[idx];\n\n                if (note.pitch == smf[p + 1] && note.stop == null) {\n                  note.stop = tick;\n                  note.stopTime = time; // nowNoteOnIdxAry.splice(i, 1); を軽量化\n\n                  if (i == nowNoteOnIdxAry.length - 1) nowNoteOnIdxAry.pop();else if (i == 0) nowNoteOnIdxAry.shift();else nowNoteOnIdxAry.splice(i, 1);\n                }\n              });\n              nowNoteOnIdxAry.push(channel.notes.length);\n              channel.notes.push(note);\n\n              if (tick < firstNoteOnTiming) {\n                firstNoteOnTiming = tick;\n                firstNoteOnTime = time;\n              }\n            } else {\n              nowNoteOnIdxAry.some(function (idx, i) {\n                var note = channel.notes[idx];\n\n                if (note.pitch == smf[p + 1] && note.stop == null) {\n                  if (hold >= that.settings.holdOnValue) {\n                    if (note.holdBeforeStop == null) {\n                      note.holdBeforeStop = [{\n                        timing: tick,\n                        time: time,\n                        value: hold\n                      }];\n                    }\n                  } else {\n                    note.stop = tick;\n                    note.stopTime = time; // nowNoteOnIdxAry.splice(i, 1); を軽量化\n\n                    if (i == nowNoteOnIdxAry.length - 1) nowNoteOnIdxAry.pop();else if (i == 0) nowNoteOnIdxAry.shift();else nowNoteOnIdxAry.splice(i, 1);\n                  }\n\n                  if (tick > lastNoteOffTiming) {\n                    lastNoteOffTiming = tick;\n                    lastNoteOffTime = time;\n                  }\n\n                  return true;\n                }\n              });\n            }\n\n            break;\n          // Polyfonic Key Pressure - A[ch], Pitch?, Velocity?\n\n          case 0xA:\n            break;\n          // Control Change - B[ch],,\n\n          case 0xB:\n            switch (smf[p + 1]) {\n              case 1:\n                modulation = smf[p + 2];\n                nowNoteOnIdxAry.forEach(function (idx) {\n                  var note = channel.notes[idx];\n                  note.modulation.push({\n                    timing: tick,\n                    time: time,\n                    value: modulation\n                  });\n                });\n                break;\n\n              case 6:\n                if (rpnLsb == 0 && rpnMsb == 0) {\n                  // RLSB=0 & RMSB=0 -> 6はピッチ\n                  dataEntry = smf[p + 2];\n\n                  if (dataEntry > 24) {\n                    dataEntry = 24;\n                  }\n                }\n\n                if (nrpnLsb == 8 && nrpnMsb == 1) {// (保留)ビブラート・レイト(GM2/GS/XG)\n                  //console.log(\"CC  8 1 6 \"+smf[p+2]+\" tick:\"+tick);\n                } else if (nrpnLsb == 9 && nrpnMsb == 1) {// (保留)ビブラート・デプス(GM2/GS/XG)\n                  //console.log(\"CC  9 1 6 \"+smf[p+2]+\" tick:\"+tick);\n                } else if (nrpnLsb == 10 && nrpnMsb == 1) {// (保留)ビブラート・ディレイ(GM2/GS/XG)\n                  //console.log(\"CC 10 1 6 \"+smf[p+2]+\" tick:\"+tick);\n                }\n\n                break;\n\n              case 7:\n                velocity = smf[p + 2];\n                break;\n\n              case 10:\n                //Pan\n                pan = smf[p + 2];\n                nowNoteOnIdxAry.forEach(function (idx) {\n                  var note = channel.notes[idx];\n                  note.pan.push({\n                    timing: tick,\n                    time: time,\n                    value: pan\n                  });\n                });\n                break;\n\n              case 11:\n                //Expression\n                expression = smf[p + 2];\n                nowNoteOnIdxAry.forEach(function (idx) {\n                  var note = channel.notes[idx];\n                  note.expression.push({\n                    timing: tick,\n                    time: time,\n                    value: expression * (masterVolume / 127)\n                  });\n                });\n                break;\n\n              case 64:\n                //Hold1\n                hold = smf[p + 2];\n\n                if (hold < this.settings.holdOnValue) {\n                  for (var i = nowNoteOnIdxAry.length - 1; i >= 0; i--) {\n                    var idx = nowNoteOnIdxAry[i];\n                    var note = channel.notes[idx];\n\n                    if (note.stop == null && note.holdBeforeStop != null) {\n                      note.stop = tick;\n                      note.stopTime = time; // nowNoteOnIdxAry.splice(i, 1); を軽量化\n\n                      if (i == nowNoteOnIdxAry.length - 1) nowNoteOnIdxAry.pop();else if (i == 0) nowNoteOnIdxAry.shift();else nowNoteOnIdxAry.splice(i, 1);\n                    }\n                  }\n                }\n\n                break;\n\n              case 91:\n                reverb = smf[p + 2];\n                nowNoteOnIdxAry.forEach(function (idx) {\n                  var note = channel.notes[idx];\n                  note.reverb.push({\n                    timing: tick,\n                    time: time,\n                    value: reverb\n                  });\n                });\n                break;\n\n              case 93:\n                chorus = smf[p + 2];\n                nowNoteOnIdxAry.forEach(function (idx) {\n                  var note = channel.notes[idx];\n                  note.chorus.push({\n                    timing: tick,\n                    time: time,\n                    value: chorus\n                  });\n                });\n                break;\n\n              case 98:\n                nrpnLsb = smf[p + 2];\n                break;\n\n              case 99:\n                nrpnMsb = smf[p + 2];\n                break;\n\n              case 100:\n                rpnLsb = smf[p + 2];\n                break;\n\n              case 101:\n                rpnMsb = smf[p + 2];\n                break;\n\n              case 111:\n                // RPGツクール用ループ\n                if (cc111Tick == -1) {\n                  cc111Tick = tick;\n                  cc111Time = time;\n                }\n\n                break;\n            }\n\n            break;\n          // Program Change - C[ch],\n\n          case 0xC:\n            instrument = smf[p + 1];\n            break;\n          // Channel Pre - D[ch],\n\n          case 0xD:\n            break;\n          // PitchBend Change - E[ch],,\n\n          case 0xE:\n            pitchBend = (smf[p + 2] * 128 + smf[p + 1] - 8192) / 8192 * dataEntry;\n            nowNoteOnIdxAry.forEach(function (idx) {\n              var note = channel.notes[idx];\n              note.pitchBend.push({\n                timing: tick,\n                time: time,\n                value: pitchBend\n              });\n            });\n            break;\n\n          case 0xF:\n            //lastState = smf[p]; <- ランニングナントカは無いらしい\n            switch (smf[p]) {\n              case 0xF0:\n              case 0xF7:\n                // Master Volume\n                if (smf[p + 1] == 0x7f && smf[p + 2] == 0x7f && smf[p + 3] == 0x04 && smf[p + 4] == 0x01) {\n                  var vol = smf[p + 6];\n                  if (vol > 127) vol = 127;\n                  masterVolume = vol;\n                  nowNoteOnIdxAry.forEach(function (idx) {\n                    var note = channel.notes[idx];\n                    note.expression.push({\n                      timing: tick,\n                      time: time,\n                      value: expression * (masterVolume / 127)\n                    });\n                  });\n                }\n\n                break;\n\n              case 0xFF:\n                // Meta Events\n                switch (smf[p + 1]) {\n                  case 0x51:\n                    // Tempo\n                    tempoCurTime += 60 / tempo / header.resolution * (tick - tempoCurTick);\n                    tempoCurTick = tick;\n                    tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);\n                    break;\n                }\n\n            }\n\n            break;\n\n          default:\n            {\n              return \"Error parseSMF.\";\n            }\n        }\n\n        indIdx = nextIdx;\n      }\n\n      channel.nowNoteOnIdxAry = nowNoteOnIdxAry;\n\n      if (!this.debug) {\n        delete channel.indices;\n      }\n    } // hold note off\n\n\n    for (var ch = 0; ch < 16; ch++) {\n      var channel = channels[ch];\n      var nowNoteOnIdxAry = channels[ch].nowNoteOnIdxAry;\n\n      for (var i = nowNoteOnIdxAry.length - 1; i >= 0; i--) {\n        var note = channel.notes[nowNoteOnIdxAry[i]];\n\n        if (note.stop == null) {\n          note.stop = lastNoteOffTiming;\n          note.stopTime = lastNoteOffTime; // If (note.cc[x].timing > lastNoteOffTiming), delete note.cc[x]\n\n          var nameAry = [\"pitchBend\", \"pan\", \"expression\", \"modulation\", \"reverb\", \"chorus\"];\n          nameAry.forEach(function (name) {\n            var ccAry = note[name];\n\n            for (var i2 = ccAry.length - 1; i2 >= 1; i2--) {\n              var obj = ccAry[i2];\n\n              if (obj.timing > lastNoteOffTiming) {\n                // ccAry.splice(i2, 1); を軽量化\n                if (i2 == ccAry.length - 1) ccAry.pop();else if (i2 == 0) ccAry.shift();else ccAry.splice(i2, 1);\n              }\n            }\n          }); // nowNoteOnIdxAry.splice(i, 1); を軽量化\n\n          if (i == nowNoteOnIdxAry.length - 1) nowNoteOnIdxAry.pop();else if (i == 0) nowNoteOnIdxAry.shift();else nowNoteOnIdxAry.splice(i, 1);\n        }\n      }\n\n      delete channel.nowNoteOnIdxAry;\n    }\n\n    if (this.settings.isSkipEnding) songLength = lastNoteOffTiming;\n    tempoTrack.push({\n      timing: songLength,\n      time: 60 / tempo / header.resolution * (songLength - tempoCurTick) + tempoCurTime,\n      value: 120\n    });\n\n    if (this.settings.isWebMIDI) {\n      var channel = channels[16];\n      var tempo = 120;\n      var tempoCurTick = 0;\n      var tempoCurTime = 0;\n      var indIdx = channel.indicesHead;\n      var indices = channel.indices;\n\n      while (indIdx != -1) {\n        var tick = indices[indIdx];\n        var pLen = indices[indIdx + 1];\n        var p = indices[indIdx + 2];\n        var nextIdx = indices[indIdx + 3];\n        var time = 60 / tempo / header.resolution * (tick - tempoCurTick) + tempoCurTime; // Events\n\n        switch (smf[p]) {\n          case 0xFF:\n            // Meta Events\n            switch (smf[p + 1]) {\n              case 0x51:\n                // Tempo\n                tempoCurTime += 60 / tempo / header.resolution * (tick - tempoCurTick);\n                tempoCurTick = tick;\n                tempo = 60000000 / (smf[p + 3] * 0x10000 + smf[p + 4] * 0x100 + smf[p + 5]);\n                break;\n            }\n\n        }\n\n        messages.push({\n          time: time,\n          tick: tick,\n          smfPtr: p,\n          smfPtrLen: pLen\n        });\n        indIdx = nextIdx;\n      }\n    }\n\n    data.header = header;\n    data.tempoTrack = tempoTrack;\n    data.beatTrack = beatTrack;\n    data.channels = channels;\n    data.songLength = songLength;\n    data.cc111Tick = cc111Tick;\n    data.cc111Time = cc111Time;\n    data.firstNoteOnTiming = firstNoteOnTiming;\n    data.firstNoteOnTime = firstNoteOnTime;\n    data.lastNoteOffTiming = lastNoteOffTiming;\n    data.lastNoteOffTime = lastNoteOffTime;\n\n    if (this.settings.isWebMIDI) {\n      data.messages = messages;\n      data.smfData = new Uint8Array(smf); // lastStateを上書きしたsmfをコピー\n    }\n\n    if (this.debug) {\n      var syoriTimeE = performance.now();\n      console.log(\"parseSMF time\", syoriTimeE - syoriTimeS);\n      console.log(\"parseSMF(0/2) time\", syoriTimeS1_1 - syoriTimeS);\n      console.log(\"parseSMF(1/2) time\", syoriTimeS2 - syoriTimeS);\n      console.log(\"parseSMF(2/2) time\", syoriTimeE - syoriTimeS2);\n      console.log(data);\n    }\n\n    return data;\n  };\n\n  PicoAudio.prototype.getInt = function (arr, s, e) {\n    var value = 0;\n\n    for (var i = s; i < e; i++) {\n      value = (value << 8) + arr[i];\n    }\n\n    return value;\n  };\n\n  PicoAudio.prototype.variableLengthToInt = function (arr, s, e) {\n    var i = s;\n    var value = 0;\n\n    while (i < e - 1 && arr[i] >= 0x80) {\n      if (i < s + 4) value = (value << 7) + (arr[i] - 0x80);\n      i++;\n    }\n\n    value = (value << 7) + arr[i];\n    i++;\n    return [value, i - s];\n  };\n\n  PicoAudio.prototype.chIndicesSplice = function (ch, time, p, len) {\n    var indices = ch.indices; // メモリー足りなくなったら拡張\n\n    if (indices.length <= ch.indicesLength + 4) {\n      if (this.debug) {\n        var ts1 = performance.now();\n      }\n\n      var temp = new Int32Array(Math.floor(indices.length * 2));\n\n      for (var i = indices.length - 1; i >= 0; i--) {\n        temp[i] = indices[i];\n      }\n\n      ch.indices = indices = temp;\n\n      if (this.debug) {\n        console.log(\"malloc\", performance.now() - ts1, temp.length);\n      }\n    } // デルタタイムの順番になるようにリスト配列に挿入\n\n\n    if (ch.indicesLength >= 4 && time < indices[ch.indicesFoot]) {\n      // Insert\n      while (ch.indicesCur != -1) {\n        if (time < indices[ch.indicesCur]) {\n          if (ch.indicesCur == ch.indicesHead) {\n            ch.indicesHead = ch.indicesLength;\n          } else {\n            indices[ch.indicesPre + 3] = ch.indicesLength;\n          }\n\n          indices[ch.indicesLength] = time;\n          indices[ch.indicesLength + 1] = len;\n          indices[ch.indicesLength + 2] = p;\n          indices[ch.indicesLength + 3] = ch.indicesCur;\n          ch.indicesPre = ch.indicesLength;\n          ch.indicesLength += 4;\n          break;\n        }\n\n        ch.indicesPre = ch.indicesCur;\n        ch.indicesCur = indices[ch.indicesCur + 3];\n      }\n    } else {\n      // Push\n      if (ch.indicesLength >= 4) {\n        indices[ch.indicesFoot + 3] = ch.indicesLength;\n      } else {\n        ch.indicesHead = 0;\n      }\n\n      ch.indicesFoot = ch.indicesLength;\n      indices[ch.indicesLength] = time;\n      indices[ch.indicesLength + 1] = len;\n      indices[ch.indicesLength + 2] = p;\n      indices[ch.indicesLength + 3] = -1;\n      ch.indicesLength += 4;\n    }\n  };\n\n  PicoAudio.prototype.stopAudioNode = function (tar, time, stopGainNode, isNoiseCut) {\n    var isImmed = time <= this.context.currentTime; // 即時ストップか？\n    // 時間設定\n\n    if (!isImmed) {\n      // 予約ストップ\n      var vol1Time = time - 0.005;\n      var stopTime = time;\n    } else {\n      // 即時ストップ\n      if (!isNoiseCut) {\n        var stopTime = this.context.currentTime;\n      } else {\n        var vol1Time = this.context.currentTime;\n        var stopTime = this.context.currentTime + 0.005;\n      }\n    } // 音の停止\n\n\n    try {\n      if (!isNoiseCut) {\n        tar.stop(stopTime);\n      } else {\n        tar.stop(stopTime);\n        stopGainNode.gain.cancelScheduledValues(0);\n        stopGainNode.gain.setValueAtTime(1, vol1Time);\n        stopGainNode.gain.linearRampToValueAtTime(0, stopTime);\n      }\n    } catch (e) {\n      // iOS (stopが２回以上使えないので、代わりにstopGainNodeでミュートにする)\n      stopGainNode.gain.cancelScheduledValues(0);\n\n      if (!isNoiseCut) {\n        stopGainNode.gain.setValueAtTime(0, stopTime);\n      } else {\n        stopGainNode.gain.setValueAtTime(1, vol1Time);\n        stopGainNode.gain.linearRampToValueAtTime(0, stopTime);\n      }\n    }\n  };\n\n  PicoAudio.prototype.pushFunc = function (tar) {\n    if (!tar.note && !tar.rootTimeout && !tar.pan && !this.trigger.isNoteTrigger) return;\n    this.states.stopFuncs.push(tar);\n  };\n\n  PicoAudio.prototype.clearFunc = function (tar1, tar2) {\n    if (tar1 != \"note\" && tar1 != \"rootTimeout\" && tar1 != \"pan\" && !this.trigger.isNoteTrigger) return;\n    var that = this;\n    that.states.stopFuncs.some(function (n, i, ary) {\n      if (n[tar1] == tar2) {\n        // ary.splice(i, 1); を軽量化\n        if (i == 0) ary.shift();else if (i == ary.length - 1) ary.pop();else ary.splice(i, 1);\n        return true;\n      }\n    });\n  };\n\n  return PicoAudio;\n}();\n\n//# sourceURL=webpack:///./PicoAudio.js?");

/***/ })

/******/ });